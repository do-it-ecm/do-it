<!DOCTYPE html>
<html lang="fr">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="robots" content="index, follow">

        <link rel="canonical" href="https://do-it.aioli.ec-m.fr/promos/2023-2024/Dang-Vu-Duc/pok/temps-2/">

        
        

        <meta name="description" content="Ce POK a pour objectif d&#39;impl√©menter un jeu d&#39;√©checs sur Python et de cr√©er un code qui peut r√©soudre des probl√®mes simples.">
        <meta property="og:description" content="Ce POK a pour objectif d&#39;impl√©menter un jeu d&#39;√©checs sur Python et de cr√©er un code qui peut r√©soudre des probl√®mes simples.">
        <meta name="twitter:description" content="Ce POK a pour objectif d&#39;impl√©menter un jeu d&#39;√©checs sur Python et de cr√©er un code qui peut r√©soudre des probl√®mes simples.">

        
            <meta name="author" content="Duc DANG VU">
        
        <meta name="keywords" content="do-it, centrale, centrale m√©diterran√©e, ecm, POK, Pygame, Jeux, √âchecs">

        <link rel="icon" href="https://raw.githubusercontent.com/do-it-ecm/do-it/main/src/assets/img/logo/favicon.ico" type="image/x-icon">
        <link rel="icon" href="https://raw.githubusercontent.com/do-it-ecm/do-it/main/src/assets/img/logo/minimal.png" type="image/png">
        <link rel="apple-touch-icon" href="https://raw.githubusercontent.com/do-it-ecm/do-it/main/src/assets/img/logo/minimal.png">

        <link href="/assets/stylesheets/main.css" rel="stylesheet">

        <meta property="og:title" content="Impl√©mentation d&#39;un jeu d&#39;√©checs sur Python">

        <meta property="og:image" content="https://raw.githubusercontent.com/do-it-ecm/do-it/main/src/assets/img/logo/intermediate-text.png">
        <meta property="og:url" content="https://do-it.aioli.ec-m.fr/promos/2023-2024/Dang-Vu-Duc/pok/temps-2/">
        <meta property="og:type" content="website">

        <meta name="twitter:card" content="https://raw.githubusercontent.com/do-it-ecm/do-it/main/src/assets/img/logo/intermediate-text.png">
        <meta name="twitter:title" content="Impl√©mentation d&#39;un jeu d&#39;√©checs sur Python">
        <meta name="twitter:image" content="https://raw.githubusercontent.com/do-it-ecm/do-it/main/src/assets/img/logo/intermediate-text.png">
        <meta name="twitter:url" content="https://do-it.aioli.ec-m.fr/promos/2023-2024/Dang-Vu-Duc/pok/temps-2/">

        <title>Impl√©mentation d&#39;un jeu d&#39;√©checs sur Python</title>

        <!-- Prismjs imports
                - Prism line numbers
                - Prism toolbar
        -->
        <link href="https://cdn.jsdelivr.net/npm/prismjs/plugins/toolbar/prism-toolbar.min.css" rel="stylesheet">
        <link id="prism-theme" href="https://cdn.jsdelivr.net/npm/prismjs/themes/prism-solarizedlight.min.css" rel="stylesheet">
        <link href="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet">

        <!-- Mermaid import and initialization -->
        <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js "></script>

        <script defer="">
        // Check if a theme is stored in localStorage. If so, use it, otherwise fallback to the system preference.
        const storedTheme = localStorage.getItem('theme');
        if (storedTheme) {
            document.documentElement.classList.toggle("dark", storedTheme === "dark");
        } else {
            // Use system color scheme if there is no stored theme preference.
            document.documentElement.classList.toggle("dark", window.matchMedia("(prefers-color-scheme: dark)").matches);
        }

        function loadPrismTheme(isDarkMode) {
            const newTheme = isDarkMode ? 'prism-okaidia.min.css' : 'prism-solarizedlight.min.css';
            const newLink = document.createElement('link');
            newLink.rel = 'stylesheet';
            newLink.id = 'prism-theme';
            newLink.href = `https://cdn.jsdelivr.net/npm/prismjs/themes/${newTheme}`;

            newLink.onload = () => {
                // Reapply highlighting after the new theme loads
                Prism.highlightAll();
            };

            const existingLink = document.getElementById('prism-theme');
            if (existingLink) {
                document.head.replaceChild(newLink, existingLink);
            } else {
                document.head.appendChild(newLink);
            }
        }

        function setMermaidTheme(isDarkMode) {
            const theme = isDarkMode ? 'dark' : 'forest';
            mermaid.initialize({
                securityLevel: 'loose',
                theme,
                startOnLoad: true,
            });
        }

        // Toggle dark and light mode and update localStorage accordingly.
        function toggleDarkMode() {
            const dark = document.documentElement.classList.contains("dark");
            const newTheme = dark ? "light" : "dark";
            localStorage.setItem('theme', newTheme);
            document.documentElement.classList.toggle("dark", !dark);
            loadPrismTheme(!dark);
            setMermaidTheme(!dark);
        }

        // On initial load, ensure that Prism and Mermaid are initialized using the current theme.
        const isDark = document.documentElement.classList.contains("dark");
        loadPrismTheme(isDark);
        setMermaidTheme(isDark);
        </script>

    </head>

    <body data-prismjs-copy="üìã" data-prismjs-copy-error="‚ùå" data-prismjs-copy-success="‚úÖ" data-prismjs-copy-timeout="1000" class="bg-neutral-50 text-neutral-950 dark:bg-neutral-900 dark:text-neutral-50">
        <header class="fixed top-0 z-50 w-full border-b-2 border-gray-200 bg-white dark:bg-neutral-900 dark:border-neutral-700">
            <div class="max-w-[1000px] mx-auto px-4">
                <div class="min-h-[50px] flex justify-between items-center">
                    <a class="mx-2" href="/">Home</a>
                    <button class="hidden sm:block text-neutral-950 dark:text-neutral-50 hover:bg-neutral-700 hover:text-neutral-50 hover:dark:bg-neutral-300 hover:dark:text-neutral-950 transition-colors p-2 rounded-full duration-800 ease-in-out" onclick="toggleDarkMode()">
                        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="h-5 aspect-square fill-none aspect-square stroke-2 dark:hidden stroke-current">
                            <circle cx="12" cy="12" r="5"></circle>
                            <path d="M12 2V4" stroke-linecap="round"></path>
                            <path d="M12 20V22" stroke-linecap="round"></path>
                            <path d="M4 12L2 12" stroke-linecap="round"></path>
                            <path d="M22 12L20 12" stroke-linecap="round"></path>
                            <path d="M19.7778 4.22266L17.5558 6.25424" stroke-linecap="round"></path>
                            <path d="M4.22217 4.22266L6.44418 6.25424" stroke-linecap="round"></path>
                            <path d="M6.44434 17.5557L4.22211 19.7779" stroke-linecap="round"></path>
                            <path d="M19.7778 19.7773L17.5558 17.5551" stroke-linecap="round"></path>
                        </svg>
                        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="h-5 aspect-square fill-none aspect-square stroke-2 stroke-current hidden dark:block">
                            <path d="M3.32031 11.6835C3.32031 16.6541 7.34975 20.6835 12.3203 20.6835C16.1075 20.6835 19.3483 18.3443 20.6768 15.032C19.6402 15.4486 18.5059 15.6834 17.3203 15.6834C12.3497 15.6834 8.32031 11.654 8.32031 6.68342C8.32031 5.50338 8.55165 4.36259 8.96453 3.32996C5.65605 4.66028 3.32031 7.89912 3.32031 11.6835Z" stroke-linecap="round" stroke-linejoin="round"></path>
                        </svg>
                    </button>
                    <div class="flex items-center gap-4 sm:gap-6 ">
                        <a class="" href="/cs">CS</a>
                        <a class="" href="/pok">POK</a>
                        <a class="" href="/mon">MON</a>
                        <a class="" href="/projets">Projets</a>
                        <a class="hidden sm:block" href="/promos">Promos</a>
                        <a href="/search">
                            <svg class="h-5 aspect-square stroke-neutral-950 dark:stroke-neutral-300 fill-none stroke-2" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607z"></path>
                            </svg>
                        </a>
                        <a class="hidden sm:block" href="https://github.com/do-it-ecm/do-it" target="_blank">
                            <svg class="h-5 aspect-square dark:stroke-neutral-300 dark:fill-neutral-300" role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>GitHub</title><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"></path></svg>
                        </a>
                    </div>
                </div>
            </div>
        </header>

        <main class="mt-[66px] max-w-[1000px] mx-auto px-4" data-pagefind-body="">
            
<article class="relative">
<h1 class="mb-1">Impl√©mentation d&#39;un jeu d&#39;√©checs sur Python</h1>
<div class="mb-4">
    
        <div class="px-4 flex flex-wrap items-center">
            <div class="font-bold">Tags : </div>
            <ul class="flex flex-wrap overflow-auto not-prose list-none my-1 mx-0 px-1 gap-1" data-pagefind-meta="Tags">
                
                    <li class="bg-yellow-200 rounded-full px-2 text-neutral-950" data-pagefind-filter="Tags">POK</li>
                
                    <li class="bg-yellow-200 rounded-full px-2 text-neutral-950" data-pagefind-filter="Tags">Pygame</li>
                
                    <li class="bg-yellow-200 rounded-full px-2 text-neutral-950" data-pagefind-filter="Tags">Jeux</li>
                
                    <li class="bg-yellow-200 rounded-full px-2 text-neutral-950" data-pagefind-filter="Tags">√âchecs</li>
                

            </ul>

            
            <div class="hidden" data-pagefind-meta="Type" aria-hidden="true">
                
                    
                        <span data-pagefind-filter="Type">POK</span>
                    
                
                    
                
                    
                
                    
                
            </div>
        </div>
    

    
        <div class="px-4 flex flex-wrap items-center">
            <div class="font-bold">Auteur : </div>
            <ul class="flex flex-wrap not-prose list-none my-1 mx-0 px-1 gap-1" data-pagefind-meta="Auteurs">
                
                    <li class="bg-blue-200 rounded-full px-2 text-neutral-950" data-pagefind-filter="Auteurs">Duc DANG VU</li>
                
            </ul>
        </div>
    

    
        <div class="absolute top-0 right-0">
            <span class="bg-purple-200 rounded-full px-3 py-1 mt-2 mr-2 text-neutral-950" data-pagefind-filter="Ann√©e">
                2023-2024
            </span>
        </div>
    
</div>

<p class="mb-4 text-lg">Ce POK a pour objectif d'impl√©menter un jeu d'√©checs sur Python et de cr√©er un code qui peut r√©soudre des probl√®mes simples.</p>



    
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-purple-500 bg-purple-100 dark:border-purple-800 dark:bg-purple-950">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 fill-none stroke-2 stroke-purple-500 dark:stroke-purple-800" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 19a2 2 0 01-2-2V7a2 2 0 012-2h4l2 2h4a2 2 0 012 2v1M5 19h14a2 2 0 002-2v-5a2 2 0 00-2-2H9a2 2 0 00-2 2v5a2 2 0 01-2 2z"></path>
</svg>
<div class="pl-8 mr-8">

<a href="/promos/2023-2024/Dang-Vu-Duc/">Duc DANG VU</a><span class="px-1">/</span><a href="/promos/2023-2024/Dang-Vu-Duc/pok/">POK de Duc DANG VU</a><span class="px-1">/</span><a href="/promos/2023-2024/Dang-Vu-Duc/pok/temps-2/">Impl√©mentation d&#39;un jeu d&#39;√©checs sur Python</a>

</div>
</div>




<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-pink-500 bg-pink-100 dark:border-pink-800 dark:bg-pink-950">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 fill-none stroke-2 stroke-pink-500 dark:stroke-pink-800" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p>Pr√©requis</p>
</div><div class="pl-8 mr-8">
<p>Connaissance basique de la programmation objet avec Python et des r√®gles du jeu d'√©checs.</p>
</div>
</div>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100 dark:border-amber-800 dark:bg-amber-950">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 fill-none stroke-2 stroke-amber-800 dark:stroke-amber-800" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><b>Note</b></p>
</div><div class="pl-8 mr-8">
<p>Il est possible de tester l'impl√©mentation du jeu sur le lien suivant: <a href="https://duc-dgv.itch.io/jeu-dchecs">Jeu d'√©checs avec Python</a>
Tout les codes pr√©sent√©s sont disponibles dans le dossier Git du POK2: <a href="https://github.com/do-it-ecm/do-it/tree/main/src/promos/2023-2024/Dang-Vu-Duc/pok/temps-2">codes du POK2</a></p>
</div>
</div>
<h2 id="introduction" tabindex="-1"><a class="header-anchor" href="#introduction"></a> Introduction</h2>
<p>Le jeu d'√©checs est un jeu classique, mais relativement complexe √† impl√©menter. Ce POK utilisera les connaissances acquises lors du premier MON du temps 2, pour impl√©menter l'interface du jeu. Afin d'√©viter tout chevauchement entre le MON et ce POK, cette partie du POK sera r√©alis√©e lors du deuxi√®me sprint. Le premier sprint sera d√©di√© √† l'impl√©mentation du code pour r√©soudre des probl√®mes simples.</p>
<h2 id="backlog-du-premier-sprint" tabindex="-1"><a class="header-anchor" href="#backlog-du-premier-sprint"></a> Backlog du premier sprint</h2>
<p>Ce premier sprint aura donc pour objectif d'impl√©menter le code de r√©solution de probl√®mes simples. Voici les fonctionnalit√©s que devront √™tre d√©velopp√©es, ainsi que leurs complexit√©s:</p>
<ul>
<li>Impl√©mentation de la repr√©sentation d'un plateau d'√©checs (<strong>3, 30min</strong>)</li>
<li>Impl√©mentation des classes de chaque pi√®ce ainsi que leur mouvements (<strong>5, 1h30</strong>)</li>
<li>Impl√©mentation d'une m√©thode pour repr√©senter n'importe quelle position dans le code (<strong>2, 30min</strong>)</li>
<li>Impl√©mentation d'une m√©thode pour v√©rifier si une pi√®ce peut √™tre captur√©e ou non (<strong>3, 45min</strong>)</li>
<li>Impl√©mentation d'une m√©thode pour v√©rifier si un joueur est en √©chec et mat ou non (<strong>8, 3h</strong>)</li>
<li>Impl√©mentation d'une m√©thode pour r√©soudre des probl√®mes simples, en utilisant les m√©thodes pr√©c√©dentes. (<strong>8, 3h</strong>)</li>
</ul>
<h2 id="impl%C3%A9mentation-du-code-permettant-de-r%C3%A9soudre-des-probl%C3%A8mes-simples" tabindex="-1"><a class="header-anchor" href="#impl%C3%A9mentation-du-code-permettant-de-r%C3%A9soudre-des-probl%C3%A8mes-simples"></a> Impl√©mentation du code permettant de r√©soudre des probl√®mes simples</h2>
<p>La premi√®re partie de ce POK a pour objectif de cr√©er une m√©thode qui permettra de r√©soudre des probl√®mes simples du jeu des √©checs. Autrement dit, pour une position donn√©e, le programme devra donner le coup gagnant qui m√®ne √† un √©chec et mat (en 1, 2, 3 voire 4 coups). Avant d'arriver √† cette m√©thode, plusieurs √©tapes interm√©diaires sont n√©cessaires, notamment pour repr√©senter le plateau d'√©checs et ses pi√®ces.</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100 dark:border-amber-800 dark:bg-amber-950">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 fill-none stroke-2 stroke-amber-800 dark:stroke-amber-800" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><b>Note</b></p>
</div><div class="pl-8 mr-8">
<p>Toute la suite de ce POK consid√©rera que le lecteur conna√Æt les r√®gles des √©checs, ainsi que son vocabulaire de base. Les termes un peu plus techniques (clouages, pat etc...) seront expliqu√©s lorsqu'ils seront introduits.</p>
</div>
</div>
<h3 id="repr%C3%A9sentation-des-%C3%A9l%C3%A9ments-du-plateau-d'%C3%A9checs" tabindex="-1"><a class="header-anchor" href="#repr%C3%A9sentation-des-%C3%A9l%C3%A9ments-du-plateau-d'%C3%A9checs"></a> Repr√©sentation des √©l√©ments du plateau d'√©checs</h3>
<h4 id="impl%C3%A9mentation-des-cases" tabindex="-1"><a class="header-anchor" href="#impl%C3%A9mentation-des-cases"></a> Impl√©mentation des cases</h4>
<p>Les premiers √©l√©ments √† impl√©menter sont les 64 cases du plateau. On cr√©e une classe <strong>Cell</strong>, qui contient les attributs suivants:</p>
<ul>
<li><em>row</em> et <em>column</em>: entiers correspondant √† la ligne et √† la colonne de la case (en commen√ßant par l'indice 0).</li>
<li><em>name</em>: cha√Æne de caract√®re correspondant au nom de la case. Par exemple, la case √† la ligne d'indice 3 et √† la colonne d'indice 5 aura comme nom &quot;D6&quot;.</li>
<li><em>promote</em>: correspond au cas particulier de la promotion, qui sera expliqu√©e plus en d√©tail plus tard.</li>
</ul>
<p>Ces cases vont √™tre incluses dans la liste repr√©sentant le plateau d'√©checs.</p>
<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100 cursor-pointer select-none dark:border-indigo-800 dark:bg-indigo-950">
<details class="group">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 fill-none stroke-2 stroke-indigo-500 dark:stroke-indigo-800" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 fill-none stroke-2 stroke-indigo-500 dark:stroke-indigo-800" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block group-open:select-text">
<p>Cliquer pour voir le code de la classe <strong>Cell</strong></p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 fill-none stroke-2 stroke-indigo-500 dark:stroke-indigo-800" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2 cursor-auto select-text">
<pre class="language-python line-numbers"><code>

class Cell():
    def __init__(self, row, column, promote = None):
        self.name = chr(column + 97) + f"{row+1}"
        self.row = row
        self.column = column
        self.promote = promote


</code></pre></div>
</details>
</div>
<h4 id="impl%C3%A9mentations-des-pi%C3%A8ces" tabindex="-1"><a class="header-anchor" href="#impl%C3%A9mentations-des-pi%C3%A8ces"></a> Impl√©mentations des pi√®ces</h4>
<p>Il faut maintenant impl√©menter les diff√©rentes pi√®ces du jeu, ainsi que leurs mouvements. On cr√©e une classe <strong>Piece</strong> qui contient les attributs suivants:</p>
<ul>
<li><em>possible_moves</em>: liste d'objets de la classe <strong>Cell</strong> qui contiendra toutes les cases vers lesquelles la pi√®ce pourra aller.</li>
<li><em>current_cell</em>: objet de la classe <strong>Cell</strong> qui correspond √† la case sur laquelle se trouve la pi√®ce.</li>
<li><em>IsWhite</em>: bool√©en indiquant si la pi√®ce est blanche (<em>True</em>) ou noire (<em>False</em>)</li>
<li><em>value</em>: entier correspondant √† la valeur de la pi√®ce (1 pour un Pion, 3 pour un Cavalier et un Fou, 5 pour une Tour, 9 pour une Dame et 1000 pour un Roi).</li>
<li><em>letter</em>: cha√Æne de caract√®re correspondant √† la lettre de la pi√®ce (en notation anglaise). Cette lettre sera en majuscule si la pi√®ce est blanche et en minuscule si la pi√®ce est noire.</li>
</ul>
<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100 cursor-pointer select-none dark:border-indigo-800 dark:bg-indigo-950">
<details class="group">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 fill-none stroke-2 stroke-indigo-500 dark:stroke-indigo-800" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 fill-none stroke-2 stroke-indigo-500 dark:stroke-indigo-800" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block group-open:select-text">
<p>Cliquer pour voir le code de la classe <strong>Piece</strong></p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 fill-none stroke-2 stroke-indigo-500 dark:stroke-indigo-800" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2 cursor-auto select-text">
<pre class="language-python line-numbers"><code>

class Piece():
    def __init__(self, IsWhite, value, letter, current_cell):
        self.possible_moves = []
        self.current_cell = current_cell
        self.IsWhite = IsWhite
        self.value = value
        self.letter = letter


</code></pre></div>
</details>
</div>
<p>A pr√©sent, il faut impl√©menter chaque pi√®ce. On cr√©e donc 6 classes qui correspond √† chaque pi√®ce (Pawn, Bishop, Knight, Rook, Queen, King). Ces classes h√©ritent de la classe <strong>Piece</strong>, et ont une m√©thode <em>get_possible_moves</em>. Cette m√©thode va ajouter √† l'attribut <em>possible_moves</em> toutes les cases vers lesquelles la pi√®ce peut aller. Voil√† comment fonctionnent ces m√©thodes:</p>
<ul>
<li>Pour les pi√®ces √† &quot;longue port√©e&quot; (Fou, Tour, Dame), on d√©marre avec les coordonn√©es de la pi√®ce et on part dans les 4 directions, jusqu'√† qu'on sorte des limites du plateau ou qu'on rencontre une autre pi√®ce. Dans ce dernier cas, si la couleur de cette pi√®ce n'est pas la m√™me que la pi√®ce en cours, alors on inclut cette derni√®re case (c'est une prise!). Sinon, on n'inclut pas cette case (on ne peut pas prendre une pi√®ce de notre √©quipe).</li>
<li>Pour le Cavalier et le Roi, on g√©n√®re les 8 coordonn√©es que ces pi√®ces peuvent attendre (d√©placement en &quot;L&quot; pour le Cavalier). Si une coordonn√©e sort du plateau, on ne l'inclut pas. Si une pi√®ce se trouve sur la case et que sa couleur est oppos√©e, on inclut cette case (c'est une prise!)</li>
<li>Pour le Pion, on doit v√©rifier si la case en face (ou en dessous, suivant la couleur) est vide. Si c'est le cas, on inclut cette case. Si le pion se trouve sur la deuxi√®me ligne (ou la septi√®me ligne, suivant la couleur), on ajoute une case suppl√©mentaire si possible. On v√©rifie aussi les deux cases en diagonale, ainsi que la couleur de l'√©ventuelle pi√®ce qui s'y trouve. Si cette pi√®ce est une pi√®ce de l'adversaire, on inclut cette case (c'est une prise!).</li>
</ul>
<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100 cursor-pointer select-none dark:border-indigo-800 dark:bg-indigo-950">
<details class="group">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 fill-none stroke-2 stroke-indigo-500 dark:stroke-indigo-800" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 fill-none stroke-2 stroke-indigo-500 dark:stroke-indigo-800" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block group-open:select-text">
<p>Cliquer pour voir le code des 6 classes correspondantes au pi√®ces du jeu</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 fill-none stroke-2 stroke-indigo-500 dark:stroke-indigo-800" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2 cursor-auto select-text">
<pre class="language-python line-numbers"><code>

class King(Piece):
    def __init__(self, IsWhite, current_cell):
        if IsWhite:
            super().__init__(IsWhite, 1000, "K", current_cell)
        else:
            super().__init__(IsWhite, -1000, "k", current_cell)

    def get_possible_moves(self, board):
        self.possible_moves = []
        column = self.current_cell.column
        row = self.current_cell.row
        for k in [-1, 0, 1]:
            for l in [-1, 0, 1]:
                if not (k == 0 and l == 0):
                    new_column = column + k
                    new_row = row + l
                    if new_row <= 7 and new_column <= 7 and new_row >= 0 and new_column >= 0 :
                        if board[new_row][new_column][1] is None:
                            new_cell = Cell(new_row, new_column)
                            self.possible_moves.append(new_cell)
                        else:
                            obstacle_color = board[new_row][new_column][1].IsWhite
                            if obstacle_color ^ self.IsWhite:
                                new_cell = Cell(new_row, new_column)
                                self.possible_moves.append(new_cell)

class Rook(Piece):
    def __init__(self, IsWhite, current_cell):
        if IsWhite:
            super().__init__(IsWhite, 5, "R", current_cell)
        else:
            super().__init__(IsWhite, -5, "r", current_cell)

    def get_possible_moves(self, board):
        self.possible_moves = []
        for k in [-1, 1]:
            new_column = self.current_cell.column + k
            new_row = self.current_cell.row
            while new_column >= 0 and new_column <= 7 and new_row >= 0 and new_row <= 7:
                if board[new_row][new_column][1] is None:
                        new_cell = Cell(new_row, new_column)
                        self.possible_moves.append(new_cell)
                else:
                    obstacle_color = board[new_row][new_column][1].IsWhite
                    if obstacle_color ^ self.IsWhite:
                        new_cell = Cell(new_row, new_column)
                        self.possible_moves.append(new_cell)
                    break
                new_column = new_column + k
        for l in [-1, 1]:
            new_column = self.current_cell.column
            new_row = self.current_cell.row + l
            while new_column >= 0 and new_column <= 7 and new_row >= 0 and new_row <= 7:
                if board[new_row][new_column][1] is None:
                        new_cell = Cell(new_row, new_column)
                        self.possible_moves.append(new_cell)
                else:
                    obstacle_color = board[new_row][new_column][1].IsWhite
                    if obstacle_color ^ self.IsWhite:
                        new_cell = Cell(new_row, new_column)
                        self.possible_moves.append(new_cell)
                    break
                new_row = new_row + l

class Knight(Piece):
    def __init__(self, IsWhite, current_cell):
        if IsWhite:
            super().__init__(IsWhite, 3, "N", current_cell)
        else:
            super().__init__(IsWhite, -3, "n", current_cell)

    def get_possible_moves(self, board):
        self.possible_moves = []
        column = self.current_cell.column
        row = self.current_cell.row
        L = [-1, -2, 1, 2]
        for k in L:
            temp_L = [-1, -2, 1, 2]
            temp_L.remove(k)
            temp_L.remove(-k)
            for l in temp_L:
                new_column = column + k
                new_row = row + l
                if new_row <= 7 and new_column <= 7 and new_row >= 0 and new_column >= 0:
                    if board[new_row][new_column][1] is None:
                            new_cell = Cell(new_row, new_column)
                            self.possible_moves.append(new_cell)
                    else:
                        obstacle_color = board[new_row][new_column][1].IsWhite
                        if obstacle_color ^ self.IsWhite:
                            new_cell = Cell(new_row, new_column)
                            self.possible_moves.append(new_cell)

class Bishop(Piece):
    def __init__(self, IsWhite, current_cell):
        if IsWhite:
            super().__init__(IsWhite, 3, "B", current_cell)
        else:
            super().__init__(IsWhite, -3, "b", current_cell)

    def get_possible_moves(self, board):
        self.possible_moves = []
        for k in [-1, 1]:
            for l in [-1, 1]:
                new_column = self.current_cell.column + k
                new_row = self.current_cell.row + l
                while new_column >= 0 and new_column <= 7 and new_row >= 0 and new_row <= 7:
                    if board[new_row][new_column][1] is None:
                            new_cell = Cell(new_row, new_column)
                            self.possible_moves.append(new_cell)
                    else:
                        obstacle_color = board[new_row][new_column][1].IsWhite
                        if obstacle_color ^ self.IsWhite:
                            new_cell = Cell(new_row, new_column)
                            self.possible_moves.append(new_cell)
                        break
                    new_column = new_column + k
                    new_row = new_row + l

class Queen(Piece):
    def __init__(self, IsWhite, current_cell):
        if IsWhite:
            super().__init__(IsWhite, 9, "Q", current_cell)
        else:
            super().__init__(IsWhite, -9, "q", current_cell)

    def get_possible_moves(self, board):
        self.possible_moves = []
        for k in [-1, 1]:
            new_column = self.current_cell.column + k
            new_row = self.current_cell.row
            while new_column >= 0 and new_column <= 7 and new_row >= 0 and new_row <= 7:
                if board[new_row][new_column][1] is None:
                        new_cell = Cell(new_row, new_column)
                        self.possible_moves.append(new_cell)
                else:
                    obstacle_color = board[new_row][new_column][1].IsWhite
                    if obstacle_color ^ self.IsWhite:
                        new_cell = Cell(new_row, new_column)
                        self.possible_moves.append(new_cell)
                    break
                new_column = new_column + k
        for l in [-1, 1]:
            new_column = self.current_cell.column
            new_row = self.current_cell.row + l
            while new_column >= 0 and new_column <= 7 and new_row >= 0 and new_row <= 7:
                if board[new_row][new_column][1] is None:
                        new_cell = Cell(new_row, new_column)
                        self.possible_moves.append(new_cell)
                else:
                    obstacle_color = board[new_row][new_column][1].IsWhite
                    if obstacle_color ^ self.IsWhite:
                        new_cell = Cell(new_row, new_column)
                        self.possible_moves.append(new_cell)
                    break
                new_row = new_row + l
        for k in [-1, 1]:
            for l in [-1, 1]:
                new_column = self.current_cell.column + k
                new_row = self.current_cell.row + l
                while new_column >= 0 and new_column <= 7 and new_row >= 0 and new_row <= 7:
                    if board[new_row][new_column][1] is None:
                            new_cell = Cell(new_row, new_column)
                            self.possible_moves.append(new_cell)
                    else:
                        obstacle_color = board[new_row][new_column][1].IsWhite
                        if obstacle_color ^ self.IsWhite:
                            new_cell = Cell(new_row, new_column)
                            self.possible_moves.append(new_cell)
                        break
                    new_column = new_column + k
                    new_row = new_row + l

class Pawn(Piece):
    def __init__(self, IsWhite, current_cell):
        if IsWhite:
            super().__init__(IsWhite, 1, "", current_cell)
        else:
            super().__init__(IsWhite, -1, "", current_cell)


    def get_possible_moves(self, board):
        if self.IsWhite:
            move = 1
        else:
            move = -1
        self.possible_moves = []
        if self.current_cell.row == 6 and self.IsWhite:
            new_column = self.current_cell.column + 0
            new_row = self.current_cell.row + move
            if new_column >= 0 and new_column <= 7:
                self.possible_moves.append(Cell(new_row, new_column, "Q"))
                self.possible_moves.append(Cell(new_row, new_column, "N"))
                self.possible_moves.append(Cell(new_row, new_column, "B"))
                self.possible_moves.append(Cell(new_row, new_column, "R"))
            for k in [-1, 1]:
                new_column = self.current_cell.column + k
                new_row = self.current_cell.row + move
                if new_column >= 0 and new_column <= 7:
                    if board[new_row][new_column][1] is not None:
                        obstacle_color = board[new_row][new_column][1].IsWhite
                        if obstacle_color ^ self.IsWhite:
                            self.possible_moves.append(Cell(new_row, new_column, "Q"))
                            self.possible_moves.append(Cell(new_row, new_column, "N"))
                            self.possible_moves.append(Cell(new_row, new_column, "B"))
                            self.possible_moves.append(Cell(new_row, new_column, "R"))

        elif self.current_cell.row == 1 and not self.IsWhite:
            new_column = self.current_cell.column + 0
            new_row = self.current_cell.row + move
            if new_column >= 0 and new_column <= 7:
                self.possible_moves.append(Cell(new_row, new_column, "q"))
                self.possible_moves.append(Cell(new_row, new_column, "n"))
                self.possible_moves.append(Cell(new_row, new_column, "b"))
                self.possible_moves.append(Cell(new_row, new_column, "r"))
            for k in [-1, 1]:
                new_column = self.current_cell.column + k
                new_row = self.current_cell.row + move
                if new_column >= 0 and new_column <= 7:
                    if board[new_row][new_column][1] is not None:
                        obstacle_color = board[new_row][new_column][1].IsWhite
                        if obstacle_color ^ self.IsWhite:
                            self.possible_moves.append(Cell(new_row, new_column, "q"))
                            self.possible_moves.append(Cell(new_row, new_column, "n"))
                            self.possible_moves.append(Cell(new_row, new_column, "b"))
                            self.possible_moves.append(Cell(new_row, new_column, "r"))
        else:
            if self.current_cell.row == 1 or self.current_cell.row == 6:
                for k in [1, 2]:
                    new_row = self.current_cell.row + k * move
                    new_column = self.current_cell.column + 0
                    if new_row >= 0 and new_row <= 7:
                        if board[new_row][new_column][1] is None:
                            new_cell = Cell(new_row, new_column)
                            self.possible_moves.append(new_cell)
                        else:
                            break
                    else:
                        break
            else:
                new_row = self.current_cell.row + move
                new_column = self.current_cell.column + 0
                if new_row >= 0 and new_row <= 7:
                    if board[new_row][new_column][1] is None:
                        new_cell = Cell(new_row, new_column)
                        self.possible_moves.append(new_cell)
            new_row = self.current_cell.row + move
            new_column = self.current_cell.column - 1
            if new_column >= 0 and new_row <= 7 and new_row >= 0:
                if board[new_row][new_column][1] is not None:
                    obstacle_color = board[new_row][new_column][1].IsWhite
                    if obstacle_color ^ self.IsWhite:
                        new_cell = Cell(new_row, new_column)
                        self.possible_moves.append(new_cell)

            new_column = self.current_cell.column + 1
            if new_column <= 7 and new_row <= 7 and new_row >= 0:
                if board[new_row][new_column][1] is not None:
                    obstacle_color = board[new_row][new_column][1].IsWhite
                    if obstacle_color ^ self.IsWhite:
                        new_cell = Cell(new_row, new_column)
                        self.possible_moves.append(new_cell)


</code></pre></div>
</details>
</div>
<h3 id="impl%C3%A9mentation-de-la-classe-chessboard" tabindex="-1"><a class="header-anchor" href="#impl%C3%A9mentation-de-la-classe-chessboard"></a> Impl√©mentation de la classe Chessboard</h3>
<p>Il faut maintenant impl√©menter une classe qui va permettre de repr√©senter et manipuler un plateau d'√©checs. Ce plateau sera un attribut de cette classe, et sera un tableau de 8 lignes et 8 colonnes. Chaque √©l√©ment de ce tableau sera une liste contenant un objet de la classe <strong>Cell</strong>, correspondant √† la case de l'√©chiquier, et une objet de la classe <strong>Piece</strong>, qui sera le contenu de cette case. Si la case est vide, il y aura un objet <em>None</em>.</p>
<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100 cursor-pointer select-none dark:border-indigo-800 dark:bg-indigo-950">
<details class="group">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 fill-none stroke-2 stroke-indigo-500 dark:stroke-indigo-800" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 fill-none stroke-2 stroke-indigo-500 dark:stroke-indigo-800" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block group-open:select-text">
<p>Cliquer pour voir l'initialisation de la classe <strong>Chessboard</strong></p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 fill-none stroke-2 stroke-indigo-500 dark:stroke-indigo-800" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2 cursor-auto select-text">
<pre class="language-python line-numbers"><code>

class Chessboard():
    def __init__(self):
        self.board = [ [None for j in range(8)] for i in range(8) ]
        for i in range(8):
            for j in range(8):
                self.board[i][j] = [Cell(i, j), None]


</code></pre></div>
</details>
</div>
<h4 id="r%C3%A9cup%C3%A9rer-une-position-quelconque" tabindex="-1"><a class="header-anchor" href="#r%C3%A9cup%C3%A9rer-une-position-quelconque"></a> R√©cup√©rer une position quelconque</h4>
<p>Impl√©mentons √† pr√©sent une m√©thode qui permettra de r√©cup√©rer n'importe quelle position d'√©checs. Pour cela, on va utiliser une notation appel√©e la <a href="https://fr.wikipedia.org/wiki/Notation_Forsyth-Edwards">Notation de Forsyth-Edwards</a>. Cette notation est celle utilis√©e dans le monde des √©checs pour repr√©senter une position. Pour faire court, chaque rang√©e de l'√©chiquier est d√©crite de haut en bas, et chaque pi√®ce est repr√©sent√©e par sa lettre. En lisant les lettres une par une, il n'est pas difficile de repr√©senter la position dans notre code.</p>
<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100 cursor-pointer select-none dark:border-indigo-800 dark:bg-indigo-950">
<details class="group">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 fill-none stroke-2 stroke-indigo-500 dark:stroke-indigo-800" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 fill-none stroke-2 stroke-indigo-500 dark:stroke-indigo-800" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block group-open:select-text">
<p>Cliquer pour voir le code de la m√©thode <em>get_position_from_fen</em></p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 fill-none stroke-2 stroke-indigo-500 dark:stroke-indigo-800" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2 cursor-auto select-text">
<pre class="language-python line-numbers"><code>

def get_position_from_fen(self, fen_position):
        new_board = [ [None for j in range(8)] for i in range(8) ]
        for i in range(8):
            for j in range(8):
                new_board[i][j] = [Cell(i, j), None]
        row_list = []
        word = ''
        count = 0
        for char in fen_position:
            if char != "/" and char != ' ':
                word += char
            elif char == "/":
                row_list.append(word)
                word = ''
            elif char == ' ':
                row_list.append(word)
                if fen_position[count + 1] == 'w':
                    IsWhiteToPlay = True
                else:
                    IsWhiteToPlay = False
                break
            count += 1
        nb_row = 7
        for row in row_list:
            counter = 0
            for k in range(len(row)):
                if row[k].isdigit():
                    digit = int(row[k])
                    counter += digit
                else:
                    if row[k] == 'r' or row[k] == 'R':
                        new_board[nb_row][counter][1] = Rook(row[k].isupper(), Cell(nb_row, counter))
                    elif row[k] == 'n' or row[k] == 'N':
                        new_board[nb_row][counter][1] = Knight(row[k].isupper(), Cell(nb_row, counter))
                    elif row[k] == 'b' or row[k] == 'B':
                        new_board[nb_row][counter][1] = Bishop(row[k].isupper(), Cell(nb_row, counter))
                    elif row[k] == 'k' or row[k] == 'K':
                        new_board[nb_row][counter][1] = King(row[k].isupper(), Cell(nb_row, counter))
                    elif row[k] == 'q' or row[k] == 'Q':
                        new_board[nb_row][counter][1] = Queen(row[k].isupper(), Cell(nb_row, counter))
                    elif row[k] == 'p' or row[k] == 'P':
                        new_board[nb_row][counter][1] = Pawn(row[k].isupper(), Cell(nb_row, counter))
                    counter += 1
            nb_row -= 1
        return(new_board, IsWhiteToPlay)


</code></pre></div>
</details>
</div>
<h4 id="effectuer-un-mouvement-sur-l'%C3%A9chiquier" tabindex="-1"><a class="header-anchor" href="#effectuer-un-mouvement-sur-l'%C3%A9chiquier"></a> Effectuer un mouvement sur l'√©chiquier</h4>
<p>La m√©thode <em>move</em> prend en argument une case de d√©part et une case d'arriv√©e, et modifie l'√©chiquier en cons√©quence. Pour cela, on r√©cup√®re la pi√®ce sur la case de d√©part et on v√©rifie si elle peut aller dans sa case d'arriv√©e gr√¢ce √† l'attribut <em>possible_moves</em>. Ensuite, on supprime la pi√®ce de la case de d√©part et on la place sur la case d'arriv√©e. Enfin, on actualise les attributs <em>possible_moves</em> de chaque pi√®ce en utilisant les m√©thodes <em>get_possible_moves</em>.</p>
<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100 cursor-pointer select-none dark:border-indigo-800 dark:bg-indigo-950">
<details class="group">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 fill-none stroke-2 stroke-indigo-500 dark:stroke-indigo-800" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 fill-none stroke-2 stroke-indigo-500 dark:stroke-indigo-800" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block group-open:select-text">
<p>Cliquer pour voir les codes des m√©thodes <em>move</em> et <em>update_possible_moves</em></p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 fill-none stroke-2 stroke-indigo-500 dark:stroke-indigo-800" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2 cursor-auto select-text">
<pre class="language-python line-numbers"><code>

def move(self, current_cell, final_cell):
    piece = self.board[current_cell.row][current_cell.column][1]
    if piece is None:
        print("Il n'y a pas de pi√®ce dans la case indiqu√©e")
        return()
    if (final_cell.row, final_cell.column) not in [(cell.row, cell.column) for cell in piece.possible_moves]:
        print("La pi√®ce ne peut pas aller jusqu'√† la case indiqu√©e")
        return()
    self.board[current_cell.row][current_cell.column][1] = None
    if piece.letter == "" and (current_cell.row == 6 and piece.IsWhite):
        if final_cell.promote is None:
            print("Probl√®me : pas de promotion")
            return()
        if final_cell.promote in ["Q", "q"]:
            self.board[final_cell.row][final_cell.column][1] = Queen(piece.IsWhite, final_cell)
        elif final_cell.promote in ["N", "n"]:
            self.board[final_cell.row][final_cell.column][1] = Knight(piece.IsWhite, final_cell)
        elif final_cell.promote in ["B", "b"]:
            self.board[final_cell.row][final_cell.column][1] = Bishop(piece.IsWhite, final_cell)
        elif final_cell.promote in ["R", "r"]:
            self.board[final_cell.row][final_cell.column][1] = Rook(piece.IsWhite, final_cell)

    elif piece.letter == "" and (current_cell.row == 1 and not piece.IsWhite):
        if final_cell.promote is None:
            print("Probl√®me : pas de promotion", piece.letter, current_cell.name, final_cell.name, final_cell.promote)
            return()
        if final_cell.promote in ["Q", "q"]:
            self.board[final_cell.row][final_cell.column][1] = Queen(piece.IsWhite, final_cell)
        elif final_cell.promote in ["N", "n"]:
            self.board[final_cell.row][final_cell.column][1] = Knight(piece.IsWhite, final_cell)
        elif final_cell.promote in ["B", "b"]:
            self.board[final_cell.row][final_cell.column][1] = Bishop(piece.IsWhite, final_cell)
        elif final_cell.promote in ["R", "r"]:
            self.board[final_cell.row][final_cell.column][1] = Rook(piece.IsWhite, final_cell)
    elif piece.letter in ["K", "k"]:
        self.board[final_cell.row][final_cell.column][1] = King(piece.IsWhite, final_cell)
    elif piece.letter in ["R", "r"]:
        self.board[final_cell.row][final_cell.column][1] = Rook(piece.IsWhite, final_cell)
    elif piece.letter in ["B", "b"]:
        self.board[final_cell.row][final_cell.column][1] = Bishop(piece.IsWhite, final_cell)
    elif piece.letter in ["N", "n"]:
        self.board[final_cell.row][final_cell.column][1] = Knight(piece.IsWhite, final_cell)
    elif piece.letter in ["Q", "q"]:
        self.board[final_cell.row][final_cell.column][1] = Queen(piece.IsWhite, final_cell)
    elif piece.letter in [""]:
        self.board[final_cell.row][final_cell.column][1] = Pawn(piece.IsWhite, final_cell)
    self.update_possible_moves()

def update_possible_moves(self):
    for row in self.board:
        for cell in row:
            if cell[1] is not None:
                cell[1].get_possible_moves(self.board)


</code></pre></div>
</details>
</div>
<p>Le cas de la promotion sera expliqu√© plus tard, car c'est un cas qui a √©t√© trait√© en dernier lors de ce sprint.</p>
<h4 id="d%C3%A9terminer-si-une-pi%C3%A8ce-peut-%C3%AAtre-captur%C3%A9e-par-ou-pas" tabindex="-1"><a class="header-anchor" href="#d%C3%A9terminer-si-une-pi%C3%A8ce-peut-%C3%AAtre-captur%C3%A9e-par-ou-pas"></a> D√©terminer si une pi√®ce peut √™tre captur√©e par ou pas</h4>
<p>Cette m√©thode est tr√®s importante, car elle est utilis√©e dans beaucoup de m√©thodes ci-apr√®s. Pour cela, on r√©cup√®re tout les mouvements possibles du plateau, et on v√©rifie si les coordonn√©es de la pi√®ce en question est dans cette liste.</p>
<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100 cursor-pointer select-none dark:border-indigo-800 dark:bg-indigo-950">
<details class="group">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 fill-none stroke-2 stroke-indigo-500 dark:stroke-indigo-800" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 fill-none stroke-2 stroke-indigo-500 dark:stroke-indigo-800" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block group-open:select-text">
<p>Cliquer pour voir le code de la m√©thode <em>CanBeCaptured</em></p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 fill-none stroke-2 stroke-indigo-500 dark:stroke-indigo-800" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2 cursor-auto select-text">
<pre class="language-python line-numbers"><code>

def CanBeCaptured(self, piece):
    captured_by = []
    opponent_moves = [[cell[0], cell[1]] for cell in self.get_all_possible_moves2(not piece.IsWhite)]
    for k in range(len(opponent_moves)):
        for i in range(len(opponent_moves[k][1])):
            current_cell = opponent_moves[k][1][i]
            if piece.current_cell.name == current_cell.name:
                captured_by.append(opponent_moves[k][0])
                break
    if len(captured_by) == 0:
        return(False, captured_by)
    else:
        return(True, captured_by)


</code></pre></div>
</details>
</div>
<h4 id="r%C3%A9cup%C3%A9rer-tout-les-mouvements-possibles-d'une-position" tabindex="-1"><a class="header-anchor" href="#r%C3%A9cup%C3%A9rer-tout-les-mouvements-possibles-d'une-position"></a> R√©cup√©rer tout les mouvements possibles d'une position</h4>
<p>Il faut ensuite r√©cup√©rer tout les coups possibles d'une position. Pour cela, on parcourt le plateau et quand on rencontre une pi√®ce, on rajoute dans une liste la case de d√©part et les cases d'arriv√©e. Une chose importante √† faire est de trier cette liste finale. On place en premier les mouvements qui r√©sultent en un √©chec. Ceci est important car ces mouvements sont plus susceptibles de r√©soudre le probl√®me, et cela va consid√©rablement r√©duire le temps d'ex√©cution de l'algorithme.</p>
<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100 cursor-pointer select-none dark:border-indigo-800 dark:bg-indigo-950">
<details class="group">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 fill-none stroke-2 stroke-indigo-500 dark:stroke-indigo-800" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 fill-none stroke-2 stroke-indigo-500 dark:stroke-indigo-800" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block group-open:select-text">
<p>Cliquer pour voir le code de la m√©thode <em>get_all_possible_moves</em></p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 fill-none stroke-2 stroke-indigo-500 dark:stroke-indigo-800" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2 cursor-auto select-text">
<pre class="language-python line-numbers"><code>

def get_all_possible_moves(self, IsWhiteToPlay):
    all_possible_moves = []
    initial_board = copy.deepcopy(self.board[:])
    for row in self.board:
        for cell in row:
            if cell[1] is not None:
                self.board = copy.deepcopy(initial_board[:])
                piece = copy.deepcopy(cell[1])
                if piece.IsWhite == IsWhiteToPlay:
                    current_moves = []
                    index = -1
                    # killer_moves = []
                    for move in piece.possible_moves:
                        piece_opponent = copy.deepcopy(self.board[move.row][move.column][1])
                        self.move(piece.current_cell, move)
                        if not self.IsCheck(IsWhiteToPlay):
                            if self.IsCheck(not IsWhiteToPlay):
                                current_moves = [move] + current_moves
                            elif piece_opponent != None and ((piece_opponent.IsWhite) ^ (piece.IsWhite)):
                                current_moves = [move] + current_moves
                            elif piece.letter not in [""] and index != -1:
                                current_moves = current_moves[:index] + [move] + current_moves[index:]
                            else:
                                current_moves.append(move)
                            self.board = copy.deepcopy(initial_board[:])
                            index += 1
                        else:
                            self.board = copy.deepcopy(initial_board[:])
                    # current_moves = killer_moves + current_moves
                    all_possible_moves.append([piece.current_cell, current_moves])
    return(all_possible_moves)


</code></pre></div>
</details>
</div>
<p>Notons que cette m√©thode g√®re les &quot;clouages&quot;. Ce concept a lieu quand une pi√®ce ne peut pas bouger car si elle bouge, son roi serait en √©chec.</p>
<h4 id="d%C3%A9terminer-si-la-position-est-un-%C3%A9chec-et-mat-ou-pas" tabindex="-1"><a class="header-anchor" href="#d%C3%A9terminer-si-la-position-est-un-%C3%A9chec-et-mat-ou-pas"></a> D√©terminer si la position est un √©chec et mat ou pas</h4>
<p>Cette m√©thode a √©t√© la plus longue √† impl√©menter. Ceci est d√ª au fait que qu'il y a plusieurs cas √† v√©rifier. En effet, pour parer un √©chec, il y a plusieurs possibilit√©s:</p>
<ul>
<li>Le roi en √©chec peut simplement bouger vers une case o√π il n'est pas en √©chec,</li>
<li>Capturer la pi√®ce qui met en √©chec,</li>
<li>Interposer une pi√®ce entre le roi est la pi√®ce qui met en √©chec.</li>
</ul>
<p>La m√©thode <em>IsCheckmate</em> g√®re ces cas un par un, et renvoie un bool√©en qui indique s'il y a uun √©chec et mat ou pas.
Il est inutile d'expliquer en d√©tail comment cette fonction g√®re ces cas, mais il est int√©ressant de noter que cette m√©thode utilise la plupart des m√©thodes ci-avant.</p>
<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100 cursor-pointer select-none dark:border-indigo-800 dark:bg-indigo-950">
<details class="group">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 fill-none stroke-2 stroke-indigo-500 dark:stroke-indigo-800" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 fill-none stroke-2 stroke-indigo-500 dark:stroke-indigo-800" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block group-open:select-text">
<p>Cliquer pour voir le code de la m√©thode <em>IsCheckmate</em></p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 fill-none stroke-2 stroke-indigo-500 dark:stroke-indigo-800" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2 cursor-auto select-text">
<pre class="language-python line-numbers"><code>

def IsCheckmate(self, IsWhiteToPlay):
    initial_board = copy.deepcopy(self.board)
    count = 0
    for row in self.board:
        for cell in row:
            if cell[1] is not None:
                piece2 = copy.deepcopy(cell[1])
                # print(piece2.letter, piece2.current_cell.name)
                if (piece2.value == 1000 or piece2.value == -1000) and (piece2.IsWhite == IsWhiteToPlay):
                    list_captured = copy.deepcopy(self.CanBeCaptured(piece2)[1])
                    if self.CanBeCaptured(piece2)[0]: #V√©rifie si le roi est en √©chec
                        current_row = piece2.current_cell.row
                        current_column = piece2.current_cell.column
                        current_cell = Cell(current_row,current_column)
                        for move in piece2.possible_moves:
                            self.move(current_cell, move)
                            new_piece = self.board[move.row][move.column][1]
                            can_be_captured = self.CanBeCaptured(new_piece)[0]
                            # print(new_piece.current_cell.name, [cell.name for cell in self.CanBeCaptured(new_piece)[1]])
                            if can_be_captured:
                                count += 1
                            self.board = copy.deepcopy(initial_board)
                            self.update_possible_moves()
                        if count != len(piece2.possible_moves): #V√©rifie si le roi peut s'√©chapper ou pas
                            return(False)
                        else: #Le roi ne peut pas s'√©chapper
                            if len(list_captured) == 1: #Une pi√®ce met en √©chec
                                cell = list_captured[0]
                                piece_opponent = self.board[cell.row][cell.column][1]
                                (can_be_captured2, list_captured2) = self.CanBeCaptured(piece_opponent)
                                if can_be_captured2 and (len(list_captured2) > 1 or self.board[list_captured2[0].row][list_captured2[0].column][1].letter not in ["k", "K"]): #La pi√®ce peut √™tre prise par une pi√®ce autre que le roi
                                    index = None
                                    for m in range(len(list_captured2)):
                                        if self.board[list_captured2[m].row][list_captured2[m].column][1].letter in ["K", "k"]:
                                            index = m
                                            break
                                    if index != None:
                                        list_captured2.pop(index)
                                    c = 0
                                    for cell_opponent in list_captured2:
                                        c += 1
                                        self.move(cell_opponent, piece_opponent.current_cell)
                                        if not self.IsCheck(IsWhiteToPlay): # Au moins une pi√®ce peut prendre la pi√®ce qui met en √©chec
                                            self.board = copy.deepcopy(initial_board)
                                            return(False)
                                        self.board = copy.deepcopy(initial_board)
                                    return(True)
                                else: #La pi√®ce ne peut pas √™tre prise par une pi√®ce autre que le roi
                                    cells_inbetween = []
                                    piece_opponent = self.board[list_captured[0].row][list_captured[0].column][1]
                                    row_king = piece2.current_cell.row
                                    column_king = piece2.current_cell.column
                                    if piece_opponent.letter in ["R", "r", "q", "Q"]:
                                        if piece_opponent.current_cell.column == column_king and piece_opponent.current_cell.row > row_king: #la Tour est au-dessus du roi
                                            current_column = piece_opponent.current_cell.column
                                            current_row = piece_opponent.current_cell.row - 1
                                            while current_row != row_king and current_row >= 0:
                                                cells_inbetween.append(self.board[current_row][current_column][0])
                                                current_row -= 1
                                        elif piece_opponent.current_cell.column == column_king and piece_opponent.current_cell.row < row_king: #la Tour est en dessous du roi
                                            current_column = piece_opponent.current_cell.column
                                            current_row = piece_opponent.current_cell.row + 1
                                            while current_row != row_king and current_row <= 7:
                                                cells_inbetween.append(self.board[current_row][current_column][0])
                                                current_row += 1
                                        elif piece_opponent.current_cell.row == row_king and piece_opponent.current_cell.column > column_king: #la Tour est √† droite du roi
                                            current_column = piece_opponent.current_cell.column - 1
                                            current_row = piece_opponent.current_cell.row
                                            while current_column != column_king and current_column >= 0:
                                                cells_inbetween.append(self.board[current_row][current_column][0])
                                                current_column -= 1
                                        elif piece_opponent.current_cell.row == row_king and piece_opponent.current_cell.column < column_king: #la Tour est √† gauche du roi
                                            current_column = piece_opponent.current_cell.column + 1
                                            current_row = piece_opponent.current_cell.row
                                            while current_column != column_king and current_column <= 7:
                                                cells_inbetween.append(self.board[current_row][current_column][0])
                                                current_column += 1
                                    if piece_opponent.letter in ["B", "b", "Q", "q"]:
                                        if piece_opponent.current_cell.column > column_king and piece_opponent.current_cell.row > row_king: #le Fou est en haut √† droite du roi
                                            current_column = piece_opponent.current_cell.column - 1
                                            current_row = piece_opponent.current_cell.row - 1
                                            while current_row != row_king and current_column >= 0 and current_row >= 0:
                                                cells_inbetween.append(self.board[current_row][current_column][0])
                                                current_row -= 1
                                                current_column -= 1
                                        elif piece_opponent.current_cell.column < column_king and piece_opponent.current_cell.row < row_king: #le Fou est en bas √† gauche du roi
                                            current_column = piece_opponent.current_cell.column + 1
                                            current_row = piece_opponent.current_cell.row + 1
                                            while current_row != row_king and current_row <= 7 and current_column <= 7:
                                                cells_inbetween.append(self.board[current_row][current_column][0])
                                                current_row += 1
                                                current_column += 1
                                        elif piece_opponent.current_cell.column > column_king and piece_opponent.current_cell.row < row_king: #le Fou est en bas √† droite du roi
                                            current_column = piece_opponent.current_cell.column - 1
                                            current_row = piece_opponent.current_cell.row + 1
                                            while current_row != row_king and current_row <= 7 and current_column >= 0:
                                                cells_inbetween.append(self.board[current_row][current_column][0])
                                                current_row += 1
                                                current_column -= 1
                                        elif piece_opponent.current_cell.column < column_king and piece_opponent.current_cell.row > row_king: #le Fou est en haut √† gauche du roi
                                            current_column = piece_opponent.current_cell.column + 1
                                            current_row = piece_opponent.current_cell.row - 1
                                            while current_row != row_king and current_row >= 0 and current_column <= 7:
                                                cells_inbetween.append(self.board[current_row][current_column][0])
                                                current_row -= 1
                                                current_column += 1
                                    if piece_opponent.letter not in ["R", "r", "B", "b", "Q", "q"]: #La pi√®ce qui met en √©chec n'est ni un fou, ni une tour, ni une Dame
                                        return(True)
                                    cells_inbetween = [cell.name for cell in cells_inbetween]
                                    all_possible_moves = copy.deepcopy(self.get_all_possible_moves(IsWhiteToPlay))
                                    ending_cells = []
                                    for n in range(len(all_possible_moves)):
                                        current_cell = all_possible_moves[n][0]
                                        if self.board[current_cell.row][current_cell.column][1].letter not in ['k', 'K']:
                                            ending_cells += all_possible_moves[n][1]
                                    ending_cells = [cell.name for cell in ending_cells]
                                    for cell in ending_cells:
                                        if cell in cells_inbetween:
                                            return(False)
                                    return(True)
                            else: #2 pi√®ces ou plus mettent en √©chec
                                return(True)
                    else:
                        return(False)


</code></pre></div>
</details>
</div>
<h4 id="fonction-d'%C3%A9valuation" tabindex="-1"><a class="header-anchor" href="#fonction-d'%C3%A9valuation"></a> Fonction d'√©valuation</h4>
<p>Il faut maintenant une m√©thode qui √©value la position d'une position donn√©e. Nous allons faire tr√®s simple, √©tant donn√© que l'objectif est simplement de r√©soudre des √©checs et mat en quelques coups: l'√©valuation d'une position sera donc la somme des valeurs des pi√®ces pr√©sentes dans le plateau. S'il y a un √©chec et mat, on renvoie un score de 1000000.</p>
<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100 cursor-pointer select-none dark:border-indigo-800 dark:bg-indigo-950">
<details class="group">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 fill-none stroke-2 stroke-indigo-500 dark:stroke-indigo-800" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 fill-none stroke-2 stroke-indigo-500 dark:stroke-indigo-800" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block group-open:select-text">
<p>Cliquer pour voir le code de la m√©thode <em>evaluate</em></p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 fill-none stroke-2 stroke-indigo-500 dark:stroke-indigo-800" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2 cursor-auto select-text">
<pre class="language-python line-numbers"><code>

def evaluation(self):
    eval = 0
    if self.IsCheckmate(True):
        return(-1000000)
    elif self.IsCheckmate(False):
        return(1000000)
    for row in self.board:
        for cell in row:
            if cell[1] is not None:
                eval += cell[1].value
    return(eval)


</code></pre></div>
</details>
</div>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100 dark:border-amber-800 dark:bg-amber-950">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 fill-none stroke-2 stroke-amber-800 dark:stroke-amber-800" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mb-2 mr-8">
<p><b>Note</b></p>
</div><div class="pl-8 mr-8">
<p>Notons que cette fonction d'√©valuation est centrale dans les meilleurs robots d'√©checs. Elle est ici loin d'√™tre compl√®te, mais comme on s'int√©resse seulement √† des √©checs et mat, il est inutile de pousser plus loin cette m√©thode.</p>
</div>
</div>
<h4 id="l'algorithme-de-r%C3%A9solution" tabindex="-1"><a class="header-anchor" href="#l'algorithme-de-r%C3%A9solution"></a> L'algorithme de r√©solution</h4>
<p>Nous arrivons enfin √† l'algorithme de r√©solution. Cet algorithme va utiliser toutes les m√©thodes pr√©c√©demment pr√©sent√©es pour trouver un √©chec et mat en quelques coups. Cette m√©thode prend en entr√©e une position en notation FEN, un nombre de coups √† explorer (qui est la profondeur de calcul) et renvoie une liste de coups qui correspond √† l'√©chec et mat trouv√©.
Cet algorithme, bien connu dans la th√©orie des jeux, s'appelle <a href="https://fr.wikipedia.org/wiki/Algorithme_minimax">l'algorithme Minimax</a>. Il est inutiles d'expliquer comment fonctionne cet algorithme en d√©tail car beaucoup de documentation est disponible sur ce sujet, mais le principe g√©n√©ral repose sur le fait que l'algorithme trouve les mouvements qui permet de minimiser le score pour un joueur et maximiser ce m√™me score pour l'autre joueur. Ce score est trouv√© gr√¢ce √† la m√©thode <em>evaluate</em>. Notons √©galement que j'ai √©galement impl√©menter <a href="https://fr.wikipedia.org/wiki/%C3%89lagage_alpha-b%C3%AAta">l'√©lagage &quot;Alpha-Beta&quot;</a> qui permet de r√©duire consid√©rablement le temps d'ex√©cution, en coupant les branches de l'arbre qui sont inutiles √† explorer.</p>
<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100 cursor-pointer select-none dark:border-indigo-800 dark:bg-indigo-950">
<details class="group">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 fill-none stroke-2 stroke-indigo-500 dark:stroke-indigo-800" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 fill-none stroke-2 stroke-indigo-500 dark:stroke-indigo-800" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block group-open:select-text">
<p>Cliquer pour voir le code de la m√©thode <em>solve</em></p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 fill-none stroke-2 stroke-indigo-500 dark:stroke-indigo-800" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2 cursor-auto select-text">
<pre class="language-python line-numbers"><code>

def solve(self, fen_position, IsWhiteToPlay, depth):
    self.c = 0
    self.tot = 0
    self.best_moves = [None for i in range(depth)]
    variations = []
    (self.board, IsWhiteToPlay) = self.get_position_from_fen(fen_position)
    self.update_possible_moves()
    time_begin = time.time()
    result = self.solve_assist(IsWhiteToPlay, -9999999999, 9999999999, depth)
    time_final = time.time()
    tot_time = round(time_final - time_begin, 1)
    tot_min = int((tot_time // 60) % 60)
    tot_hours = int(tot_time // 3600)
    tot_sec = round(tot_time % 60,1)
    print(f"Dur√©e de l'ex√©cution: {tot_hours} heures, {tot_min} minutes et {tot_sec} secondes")
    return(result)

def solve_assist(self, IsWhiteToPlay, alpha, beta, depth):
    # print(depth, self.IsCheckmate(True))
    self.c += 1
    print(f"{self.c}/{self.tot}", self.evaluation())
    if depth == 0 or self.IsCheckmate(True) or self.IsCheckmate(False):
        return(self.evaluation(), self.best_moves)
    if IsWhiteToPlay:
        best = -99999999999
        all_possible_moves = self.get_all_possible_moves(IsWhiteToPlay)
        flag = False
        IsStalemate = True
        for k in range(len(all_possible_moves)):
            self.tot += len(all_possible_moves[k][1])
        for move in all_possible_moves:
            for i in range(len(move[1])):
                initial_board = copy.deepcopy(self.board[:])
                initial_best_moves = copy.deepcopy(self.best_moves[:])
                self.move(move[0], move[1][i])
                IsStalemate = False
                val = self.solve_assist(not IsWhiteToPlay, alpha, beta, depth - 1)[0]
                self.board = copy.deepcopy(initial_board[:])
                if val > best:
                    best = val
                    next_move = ""
                    if move[1][i].promote != None:
                        if self.board[move[1][i].row][move[1][i].column][1] != None:
                            next_move = f"{chr(move[0].column + 97)}" + "x" + f"{move[1][i].name}" + "=" + f"{move[1][i].promote}"
                        else:
                            next_move = f"{move[1][i].name}" + "=" + f"{move[1][i].promote}"
                    else:
                        if self.board[move[0].row][move[0].column][1].letter == "" and self.board[move[1][i].row][move[1][i].column][1] != None:
                            next_move = f"{chr(move[0].column + 97)}" + next_move
                        if self.board[move[1][i].row][move[1][i].column][1] != None:
                            next_move = f"{self.board[move[0].row][move[0].column][1].letter}" + "x" + f"{move[1][i].name}"
                        else:
                            next_move = f"{self.board[move[0].row][move[0].column][1].letter}" + f"{move[1][i].name}"
                        if self.board[move[0].row][move[0].column][1].letter == "" and self.board[move[1][i].row][move[1][i].column][1] != None:
                            next_move = f"{chr(move[0].column + 97)}" + next_move
                    self.move(move[0], move[1][i])
                    if self.IsCheckmate(not IsWhiteToPlay):
                        next_move = next_move + "#"
                    elif self.IsCheck(not IsWhiteToPlay):
                        next_move = next_move + "+"
                    self.board = copy.deepcopy(initial_board[:])
                    self.best_moves[-depth] = next_move
                else:
                    self.best_moves = copy.deepcopy(initial_best_moves)
                alpha = max(alpha, val)
                if beta <= alpha:
                    flag = True
                    break
            if flag:
                break
        if IsStalemate:
            return(0, self.best_moves)
    else:
        best = 9999999999
        all_possible_moves = self.get_all_possible_moves(IsWhiteToPlay)
        flag = False
        IsStalemate = True
        for k in range(len(all_possible_moves)):
            self.tot += len(all_possible_moves[k][1])
        for move in all_possible_moves:
            for i in range(len(move[1])):
                initial_board = copy.deepcopy(self.board[:])
                initial_best_moves = copy.deepcopy(self.best_moves[:])
                self.move(move[0], move[1][i])
                IsStalemate = False
                val = self.solve_assist(not IsWhiteToPlay, alpha, beta, depth - 1)[0]
                self.board = copy.deepcopy(initial_board[:])
                if val < best:
                    best = val
                    next_move = ""
                    if move[1][i].promote != None:
                        if self.board[move[1][i].row][move[1][i].column][1] != None:
                            next_move = f"{chr(move[0].column + 97)}" + "x" + f"{move[1][i].name}" + "=" + f"{move[1][i].promote}"
                        else:
                            next_move = f"{move[1][i].name}" + "=" + f"{move[1][i].promote}"
                    else:
                        if self.board[move[0].row][move[0].column][1].letter == "" and self.board[move[1][i].row][move[1][i].column][1] != None:
                            next_move = f"{chr(move[0].column + 97)}" + next_move
                        if self.board[move[1][i].row][move[1][i].column][1] != None:
                            next_move = f"{self.board[move[0].row][move[0].column][1].letter}" + "x" + f"{move[1][i].name}"
                        else:
                            next_move = f"{self.board[move[0].row][move[0].column][1].letter}" + f"{move[1][i].name}"
                        if self.board[move[0].row][move[0].column][1].letter == "" and self.board[move[1][i].row][move[1][i].column][1] != None:
                            next_move = f"{chr(move[0].column + 97)}" + next_move
                    self.move(move[0], move[1][i])
                    if self.IsCheckmate(not IsWhiteToPlay):
                        next_move = next_move + "#"
                    elif self.IsCheck(not IsWhiteToPlay):
                        next_move = next_move + "+"
                    self.board = copy.deepcopy(initial_board[:])
                    self.best_moves[-depth] = next_move
                else:
                    self.best_moves = copy.deepcopy(initial_best_moves)
                beta = min(beta, val)
                if beta <= alpha:
                    flag = True
                    break
            if flag:
                break
        if IsStalemate:
            return(0, self.best_moves)
    return(best, self.best_moves)


</code></pre></div>
</details>
</div>
<h2 id="d%C3%A9monstration-du-code" tabindex="-1"><a class="header-anchor" href="#d%C3%A9monstration-du-code"></a> D√©monstration du code</h2>
<p>Pour v√©rifier si ce code fonctionne correctement, j'ai cherch√© des probl√®mes de mat en 2 et de mat en 3 sur Internet, et j'ai fait tourner l'algorithme sur ces positions. Voici un exemple sur cette position:</p>
<p><img src="https://raw.githubusercontent.com/do-it-ecm/promo-2023-2024/refs/heads/main//Dang-Vu-Duc/pok/temps-2/Image1.png" alt="Image1"></p>
<p>L'ex√©cution de l'algorithme sur cette position donne la ligne suivante: <code>['Qd5+', 'nxd5', 'Rxc6#']</code> en 55.5 secondes. D'apr√®s l'ordinateur le plus puissant du monde &quot;Stockfish&quot;, c'est bien la solution! (Notons le brillant sacrifice de Dame). Plusieurs lignes sont possibles, celle qui est donn√©e n'en est qu'un exemple.
Voici un autre exemple d'un mat en 3 sur la position suivante:</p>
<p><img src="https://raw.githubusercontent.com/do-it-ecm/promo-2023-2024/refs/heads/main//Dang-Vu-Duc/pok/temps-2/Image2.png" alt="Image2"></p>
<p>L'algorithme fournit la ligne suivante: <code>['Ke2', 'nc1+', 'Ke3', 'na2', 'd4#']</code> en 24 minutes. Encore une fois, c'est la bonne r√©ponse. On remarque cependant que la r√©solution a √©t√© bien plus longue. Ceci est d√ª au fait qu'il y a beaucoup plus de pi√®ces sur l'√©chiquier, et le nombre de mouvements explor√©s est √©galement beaucoup plus √©lev√© que le cas pr√©c√©dent.
Pour finir, voici l'exemple de r√©solution d'un mat en 4 sur la position suivante:</p>
<p><img src="https://raw.githubusercontent.com/do-it-ecm/promo-2023-2024/refs/heads/main//Dang-Vu-Duc/pok/temps-2/Image3.png" alt="Image3"></p>
<p>L'algorithme r√©sout ce probl√®me en 12 minutes et 57 secondes: <code>['Bh5', 'kxh5', 'Kg7', 'h6', 'Kf6', 'kh4', 'Kg6#']</code>. Notons que l'ex√©cution est g√©rable gr√¢ce au fait qu'il y ait peu de pi√®ces sur l'√©chiquier, et que les coups des Noirs soient forc√©s apr√®s le mouvement Fou H5. En r√©alit√©, j'ai essay√© de faire tourner l'algorithme sur d'autres probl√®mes de Mat en 4 pendant plusieurs heures, sans avoir de r√©sultat. Le mat en 4 est donc la limite, ce qui traduit le manque d'optimisation de l'algorithme.</p>
<h3 id="gestion-de-la-promotion-des-pions" tabindex="-1"><a class="header-anchor" href="#gestion-de-la-promotion-des-pions"></a> Gestion de la promotion des pions</h3>
<p>De nombreux probl√®mes repose sur une r√®gle des √©checs, nomm√©e la &quot;promotion&quot;. Cette r√®gle stipule qu'un pion a le droit de se transformer en n'importe quelle pi√®ce lorsqu'elle arrive au bout du plateau. Pour impl√©menter cela dans le code, on cr√©e un attribut <em>promote</em> dans la classe <strong>Cell</strong>. Cet attribut est par d√©faut <em>None</em>. Si un pion se trouve sur les rang√©es d'indice 1 ou 6, on change cet attribue en une pi√®ce (Tour, Dame, Fou ou Cavalier). Ensuite, dans la m√©thode move, lorsque l'attribut <em>promote</em> n'est pas <em>None</em> on avance le pion et on le change en la pi√®ce correspondante.</p>
<p>Pour tester cette impl√©mentation, on fait tourner l'algorithme sur le probl√®me suivant, qui est un mat en 2 qui n√©cessite deux promotions (Trait aux noirs):</p>
<p><img src="https://raw.githubusercontent.com/do-it-ecm/promo-2023-2024/refs/heads/main//Dang-Vu-Duc/pok/temps-2/Image4.png" alt="Image4"></p>
<p>La ligne donn√©e est: <code>['e1=n+', 'Kh2', 'f1=n#']</code>, qui est bien la solution. L'algorithme a bien compris qu'il fallait faire deux promotions en cavalier.</p>
<h2 id="bilan-du-premier-sprint-et-pr%C3%A9vision-du-deuxi%C3%A8me-sprint" tabindex="-1"><a class="header-anchor" href="#bilan-du-premier-sprint-et-pr%C3%A9vision-du-deuxi%C3%A8me-sprint"></a> Bilan du premier sprint et pr√©vision du deuxi√®me sprint</h2>
<p>J'ai r√©ussi √† d√©velopper tout les objectifs du backlog pr√©sent√© plus haut. J'ai parfois sous estim√© certaines complexit√©s, mais finalement tout s'est bien pass√©. L'algorithme que j'ai cr√©√© n'est pas du tout optimal, et manque cruellement de techniques pour rendre plus rapide l'ex√©cution. Les meilleurs robots d'√©checs explorent une profondeur de plus de 15 en seulement quelques secondes, tandis que mon programme met plusieurs heures pour une profondeur de 7... Cependant, le programme marche parfaitement pour des profondeurs faibles, ce qui me contente pour l'instant.</p>
<p>Il faut √† pr√©sent d√©crire le backlog du deuxi√®me sprint, qui aura pour objectif d'utiliser Pygame pour impl√©menter le jeu d'√©checs pour qu'on puisse y jouer. Voici ce backlog, avec les complexit√©s pour chaque fonctionnalit√©s:</p>
<ul>
<li>Repr√©sentation graphique du plateau et de ses pi√®ces <strong>(3, 1h)</strong></li>
<li>D√©tection des clics du joueur sur chaque pi√®ces, et proposition de mouvement pour chaque pi√®ces cliqu√©es <strong>(8, 2h)</strong></li>
<li>V√©rifier les √©checs et les √©checs et mat <strong>(5, 1h)</strong></li>
<li>Impl√©mentation de sons <strong>(3, 1h)</strong></li>
<li>Impl√©mentation de l'historique de la partie <strong>(8, 2h)</strong></li>
<li>Impl√©mentation de la liste des pi√®ces prises par chaque joueur <strong>(2, 30min)</strong></li>
<li>Impl√©mentation d'une fonctionnalit√© pour retourner le plateau <strong>(3, 45min)</strong></li>
<li>Tests sur le programme, d√©tection et correction des bugs <strong>(5, 1h)</strong></li>
</ul>
<h2 id="impl%C3%A9mentation-du-jeu-d'%C3%A9checs-avec-pygame" tabindex="-1"><a class="header-anchor" href="#impl%C3%A9mentation-du-jeu-d'%C3%A9checs-avec-pygame"></a> Impl√©mentation du jeu d'√©checs avec Pygame</h2>
<p>Nous allons √† pr√©sent impl√©menter le jeu d'√©checs en utilisant le module Pygame (ce module est expliqu√© dans mon <a href="../../mon/temps-2.1/">MON2.1</a>). On cr√©√© donc une nouvelle classe <strong>Chess_game</strong>, qui h√©rite de la classe pr√©c√©demment cr√©√©e <strong>Chessboard</strong>. Nous allons en effet utiliser toutes les m√©thodes d√©j√† cr√©√©es pour impl√©menter l'interface du jeu d'√©checs, comme par exemple les m√©thodes pour manipuler la repr√©sentation du plateau d'√©checs, v√©rifier s'il y a un √©chec etc...</p>
<h3 id="initialisation-de-la-classe" tabindex="-1"><a class="header-anchor" href="#initialisation-de-la-classe"></a> Initialisation de la classe</h3>
<p>Lors de l'initialisation de la classe <strong>Chess_game</strong>, nous allons introduire plusieurs variables qui nous seront utiles:</p>
<ul>
<li>Les diff√©rentes surfaces correspondant aux diff√©rentes images √† afficher sur l'√©cran (images des pi√®ces blanches et noires et du plateau de jeu).</li>
<li>La taille du plateau de jeu, d'une case du plateau de jeu, ainsi que les valeurs correspondant √† la distance entre le plateau de jeu et le bord de la fen√™tre.</li>
<li>Une liste qui contiendra les cases s√©lectionn√©es par le joueur.</li>
<li>Une liste qui contiendra l'historique des mouvements de la partie.</li>
<li>Des listes qui contiendront les pi√®ces prises par les Blancs et par les Noirs.</li>
<li>Les diff√©rents sons que l'on pourra entendre pendant le jeu.</li>
</ul>
<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100 cursor-pointer select-none dark:border-indigo-800 dark:bg-indigo-950">
<details class="group">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 fill-none stroke-2 stroke-indigo-500 dark:stroke-indigo-800" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 fill-none stroke-2 stroke-indigo-500 dark:stroke-indigo-800" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block group-open:select-text">
<p>Cliquer pour voir le code de l'initialisation de la classe <strong>Chess_game</strong></p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 fill-none stroke-2 stroke-indigo-500 dark:stroke-indigo-800" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2 cursor-auto select-text">
<pre class="language-python line-numbers"><code>

def __init__(self):
    pygame.init()
    super().__init__()
    self.set_starting_board()
    self.screen = pygame.display.set_mode((900, 550))
    self.chessboard_surface = pygame.image.load('chessboard.png')
    self.size = 480
    self.cell_size = self.size // 8
    self.chessboard_surface = pygame.transform.scale(self.chessboard_surface, (self.size, self.size))
    self.delta_x = 150
    self.delta_y = 30
    self.background_color = "White"
    self.screen.fill(self.background_color)
    self.font = pygame.font.Font(None, 30)
    pygame.display.set_caption("Jeu d'√©checs")
    self.clock = pygame.time.Clock()
    self.black_rook_surface = pygame.image.load('Chess_pieces_png/black_rook.png')
    self.black_rook_surface = pygame.transform.scale(self.black_rook_surface, (self.cell_size, self.cell_size))
    self.black_knight_surface = pygame.image.load('Chess_pieces_png/black_knight.png')
    self.black_knight_surface = pygame.transform.scale(self.black_knight_surface, (self.cell_size, self.cell_size))
    self.black_bishop_surface = pygame.image.load('Chess_pieces_png/black_bishop.png')
    self.black_bishop_surface = pygame.transform.scale(self.black_bishop_surface, (self.cell_size, self.cell_size))
    self.black_king_surface = pygame.image.load('Chess_pieces_png/black_king.png')
    self.black_king_surface = pygame.transform.scale(self.black_king_surface, (self.cell_size, self.cell_size))
    self.black_queen_surface = pygame.image.load('Chess_pieces_png/black_queen.png')
    self.black_queen_surface = pygame.transform.scale(self.black_queen_surface, (self.cell_size, self.cell_size))
    self.black_pawn_surface = pygame.image.load('Chess_pieces_png/black_pawn.png')
    self.black_pawn_surface = pygame.transform.scale(self.black_pawn_surface, (self.cell_size, self.cell_size))

    self.white_rook_surface = pygame.image.load('Chess_pieces_png/white_rook.png')
    self.white_rook_surface = pygame.transform.scale(self.white_rook_surface, (self.cell_size, self.cell_size))
    self.white_knight_surface = pygame.image.load('Chess_pieces_png/white_knight.png')
    self.white_knight_surface = pygame.transform.scale(self.white_knight_surface, (self.cell_size, self.cell_size))
    self.white_bishop_surface = pygame.image.load('Chess_pieces_png/white_bishop.png')
    self.white_bishop_surface = pygame.transform.scale(self.white_bishop_surface, (self.cell_size, self.cell_size))
    self.white_king_surface = pygame.image.load('Chess_pieces_png/white_king.png')
    self.white_king_surface = pygame.transform.scale(self.white_king_surface, (self.cell_size, self.cell_size))
    self.white_queen_surface = pygame.image.load('Chess_pieces_png/white_queen.png')
    self.white_queen_surface = pygame.transform.scale(self.white_queen_surface, (self.cell_size, self.cell_size))
    self.white_pawn_surface = pygame.image.load('Chess_pieces_png/white_pawn.png')
    self.white_pawn_surface = pygame.transform.scale(self.white_pawn_surface, (self.cell_size, self.cell_size))

    self.state = "piece_not_selected"
    self.coord_piece_selected = None
    self.cells_selected = []
    self.IsWhiteToPlay = True

    self.scrolled = False
    self.move_list = []
    self.move_count = 1
    self.scroll_count = 0
    self.font_moves_size = 27
    self.limit = 18
    self.font_moves = pygame.font.Font(None, self.font_moves_size)

    self.en_passant_cell = None

    self.pieces_taken_by_white = []
    self.pieces_taken_by_black = []
    self.pieces_taken_size = 25
    self.black_rook_surface2 = pygame.image.load('Chess_pieces_png/black_rook.png')
    self.black_rook_surface2 = pygame.transform.scale(self.black_rook_surface2, (self.pieces_taken_size, self.pieces_taken_size))
    self.black_knight_surface2 = pygame.image.load('Chess_pieces_png/black_knight.png')
    self.black_knight_surface2 = pygame.transform.scale(self.black_knight_surface2, (self.pieces_taken_size, self.pieces_taken_size))
    self.black_bishop_surface2 = pygame.image.load('Chess_pieces_png/black_bishop.png')
    self.black_bishop_surface2  = pygame.transform.scale(self.black_bishop_surface2, (self.pieces_taken_size, self.pieces_taken_size))
    self.black_king_surface2 = pygame.image.load('Chess_pieces_png/black_king.png')
    self.black_king_surface2 = pygame.transform.scale(self.black_king_surface2, (self.pieces_taken_size, self.pieces_taken_size))
    self.black_queen_surface2 = pygame.image.load('Chess_pieces_png/black_queen.png')
    self.black_queen_surface2 = pygame.transform.scale(self.black_queen_surface2, (self.pieces_taken_size, self.pieces_taken_size))
    self.black_pawn_surface2 = pygame.image.load('Chess_pieces_png/black_pawn.png')
    self.black_pawn_surface2 = pygame.transform.scale(self.black_pawn_surface2, (self.pieces_taken_size, self.pieces_taken_size))

    self.white_rook_surface2 = pygame.image.load('Chess_pieces_png/white_rook.png')
    self.white_rook_surface2 = pygame.transform.scale(self.white_rook_surface2, (self.pieces_taken_size, self.pieces_taken_size))
    self.white_knight_surface2 = pygame.image.load('Chess_pieces_png/white_knight.png')
    self.white_knight_surface2 = pygame.transform.scale(self.white_knight_surface2, (self.pieces_taken_size, self.pieces_taken_size))
    self.white_bishop_surface2 = pygame.image.load('Chess_pieces_png/white_bishop.png')
    self.white_bishop_surface2 = pygame.transform.scale(self.white_bishop_surface2, (self.pieces_taken_size, self.pieces_taken_size))
    self.white_king_surface2 = pygame.image.load('Chess_pieces_png/white_king.png')
    self.white_king_surface2 = pygame.transform.scale(self.white_king_surface2, (self.pieces_taken_size, self.pieces_taken_size))
    self.white_queen_surface2 = pygame.image.load('Chess_pieces_png/white_queen.png')
    self.white_queen_surface2 = pygame.transform.scale(self.white_queen_surface2, (self.pieces_taken_size, self.pieces_taken_size))
    self.white_pawn_surface2 = pygame.image.load('Chess_pieces_png/white_pawn.png')
    self.white_pawn_surface2 = pygame.transform.scale(self.white_pawn_surface2, (self.pieces_taken_size, self.pieces_taken_size))
    self.font_pieces_taken = pygame.font.Font(None, 25)


    self.move_sound = pygame.mixer.Sound('Sounds/move.ogg')
    self.capture_sound = pygame.mixer.Sound('Sounds/capture.ogg')
    self.check_sound = pygame.mixer.Sound('Sounds/check.ogg')
    self.castle_sound = pygame.mixer.Sound('Sounds/castle.ogg')


</code></pre></div>
</details>
</div>
<h3 id="gestion-de-l'affichage" tabindex="-1"><a class="header-anchor" href="#gestion-de-l'affichage"></a> Gestion de l'affichage</h3>
<p>Il faut tout d'abord impl√©menter des m√©thodes pour afficher les diff√©rents √©l√©ments sur l'√©cran. Ces √©l√©ments sont les suivants:</p>
<ul>
<li>Affichage du plateau de jeu (image prise sur le site <a href="https://chess.com">Chess.com</a>).</li>
<li>Affichage de la position actuelle, repr√©sent√©e par l'attribut <em>board</em> de la classe. Les images des pi√®ces viennent du site suivant: <a href="https://commons.wikimedia.org/wiki/Category:PNG_chess_pieces/Standard_transparent">Wikimedia</a></li>
<li>Affichage des pi√®ces prises par chaque joueur.</li>
<li>Affichage du bouton &quot;Recommencer&quot;.</li>
<li>Affichage du texte indiquant qui doit jouer, et qui a gagn√© au moment de la fin de partie.</li>
<li>Affichage de l'historique des coups de la partie. Cette m√©thode doit √©galement g√©rer le scroll de la liste, si jamais la le nombre de coups est trop √©lev√© pour pouvoir rentrer dans la fen√™tre. L'utilisateur pourra utiliser les fl√®ches de son clavier ou la mollette de sa souris pour d√©filer la liste √† sa guise.</li>
</ul>
<p>Certaines de ces m√©thodes d'affichage utilisent une autre m√©thode <em>draw_rect</em> qui permettent de colorer une case d'une certaine couleur.</p>
<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100 cursor-pointer select-none dark:border-indigo-800 dark:bg-indigo-950">
<details class="group">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 fill-none stroke-2 stroke-indigo-500 dark:stroke-indigo-800" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 fill-none stroke-2 stroke-indigo-500 dark:stroke-indigo-800" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block group-open:select-text">
<p>Cliquer pour voir les m√©thodes d√©di√©es √† l'affichage</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 fill-none stroke-2 stroke-indigo-500 dark:stroke-indigo-800" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2 cursor-auto select-text">
<pre class="language-python line-numbers"><code>

def display_position(self):
    if self.state == "piece_selected":
        nb_row, nb_column = self.coord_piece_selected
        if self.cells_selected[1] != []:
            self.draw_rect(nb_row, nb_column, "steelblue4")
    if self.cells_selected != []:
        for cell in self.cells_selected[1]:
            self.draw_rect(cell.row, cell.column, "lightblue3")
    if self.IsCheck(self.IsWhiteToPlay):
        self.draw_check()
    for row in self.board:
        for cell in row:
            if cell[1] is not None:
                piece = cell[1]
                if piece.IsWhite:
                    coord_x, coord_y = self.get_coordinates(piece.current_cell.row, piece.current_cell.column)
                    if piece.letter == "R":
                        white_rook_rect = self.white_rook_surface.get_rect(center = (coord_x, coord_y))
                        self.screen.blit(self.white_rook_surface, white_rook_rect)
                    elif piece.letter == "N":
                        white_knight_rect = self.white_knight_surface.get_rect(center = (coord_x, coord_y))
                        self.screen.blit(self.white_knight_surface, white_knight_rect)
                    elif piece.letter == "B":
                        white_bishop_rect = self.white_bishop_surface.get_rect(center = (coord_x, coord_y))
                        self.screen.blit(self.white_bishop_surface, white_bishop_rect)
                    elif piece.letter == "Q":
                        white_queen_rect = self.white_queen_surface.get_rect(center = (coord_x, coord_y))
                        self.screen.blit(self.white_queen_surface, white_queen_rect)
                    elif piece.letter == "K":
                        white_king_rect = self.white_king_surface.get_rect(center = (coord_x, coord_y))
                        self.screen.blit(self.white_king_surface, white_king_rect)
                    elif piece.letter == "":
                        white_pawn_rect = self.white_pawn_surface.get_rect(center = (coord_x, coord_y))
                        self.screen.blit(self.white_pawn_surface, white_pawn_rect)
                else:
                    coord_x, coord_y = self.get_coordinates(piece.current_cell.row, piece.current_cell.column)
                    if piece.letter == "r":
                        black_rook_rect = self.black_rook_surface.get_rect(center = (coord_x, coord_y))
                        self.screen.blit(self.black_rook_surface, black_rook_rect)
                    elif piece.letter == "n":
                        black_knight_rect = self.black_knight_surface.get_rect(center = (coord_x, coord_y))
                        self.screen.blit(self.black_knight_surface, black_knight_rect)
                    elif piece.letter == "b":
                        black_bishop_rect = self.black_bishop_surface.get_rect(center = (coord_x, coord_y))
                        self.screen.blit(self.black_bishop_surface, black_bishop_rect)
                    elif piece.letter == "q":
                        black_queen_rect = self.black_queen_surface.get_rect(center = (coord_x, coord_y))
                        self.screen.blit(self.black_queen_surface, black_queen_rect)
                    elif piece.letter == "k":
                        black_king_rect = self.black_king_surface.get_rect(center = (coord_x, coord_y))
                        self.screen.blit(self.black_king_surface, black_king_rect)
                    elif piece.letter == "":
                        black_pawn_rect = self.black_pawn_surface.get_rect(center = (coord_x, coord_y))
                        self.screen.blit(self.black_pawn_surface, black_pawn_rect)
def display_pieces_taken(self):
    white_rect = pygame.Rect(0, 0, self.delta_x, self.delta_y + self.size)
    pygame.draw.rect(self.screen, self.background_color, white_rect)
    score = self.evaluation()

    coord_x = self.delta_x - 100
    coord_y = self.delta_y + self.size - 1.5*self.cell_size
    black_pawn_rect = self.black_pawn_surface2.get_rect(midtop = (coord_x, coord_y))
    self.screen.blit(self.black_pawn_surface2, black_pawn_rect)
    text_black_pawn_taken = self.font_pieces_taken.render(f"x{self.pieces_taken_by_white.count('')}", False, "Black")
    text_rect = text_black_pawn_taken.get_rect(midtop = (coord_x + 23, coord_y + 5))
    self.screen.blit(text_black_pawn_taken, text_rect)

    coord_x += 55
    black_knight_rect = self.black_knight_surface2.get_rect(midtop = (coord_x, coord_y))
    self.screen.blit(self.black_knight_surface2, black_knight_rect)
    text_black_knight_taken = self.font_pieces_taken.render(f"x{self.pieces_taken_by_white.count('n')}", False, "Black")
    text_rect = text_black_knight_taken.get_rect(midtop = (coord_x + 23, coord_y + 5))
    self.screen.blit(text_black_knight_taken, text_rect)

    coord_x = self.delta_x - 100
    coord_y = self.delta_y + self.size - 1*self.cell_size
    black_bishop_rect = self.black_bishop_surface2.get_rect(midtop = (coord_x, coord_y))
    self.screen.blit(self.black_bishop_surface2, black_bishop_rect)
    text_black_bishop_taken = self.font_pieces_taken.render(f"x{self.pieces_taken_by_white.count('b')}", False, "Black")
    text_rect = text_black_bishop_taken.get_rect(midtop = (coord_x + 23, coord_y + 5))
    self.screen.blit(text_black_bishop_taken, text_rect)

    coord_x += 55
    black_rook_rect = self.black_rook_surface2.get_rect(midtop = (coord_x, coord_y))
    self.screen.blit(self.black_rook_surface2, black_rook_rect)
    text_black_rook_taken = self.font_pieces_taken.render(f"x{self.pieces_taken_by_white.count('r')}", False, "Black")
    text_rect = text_black_rook_taken.get_rect(midtop = (coord_x + 23, coord_y + 5))
    self.screen.blit(text_black_rook_taken, text_rect)

    coord_x = self.delta_x - 100
    coord_y = self.delta_y + self.size - 0.5*self.cell_size
    black_queen_rect = self.black_queen_surface2.get_rect(midtop = (coord_x, coord_y))
    self.screen.blit(self.black_queen_surface2, black_queen_rect)
    text_black_queen_taken = self.font_pieces_taken.render(f"x{self.pieces_taken_by_white.count('q')}", False, "Black")
    text_rect = text_black_queen_taken.get_rect(midtop = (coord_x + 23, coord_y + 5))
    self.screen.blit(text_black_queen_taken, text_rect)

    if score == 1000000 or score == -1000000:
        coord_x += 45
        text_score = self.font_pieces_taken.render("#", False, "Black")
        text_rect = text_score.get_rect(midtop = (coord_x + 23, coord_y + 5))
        self.screen.blit(text_score, text_rect)
    elif score > 0:
        coord_x += 45
        text_score = self.font_pieces_taken.render(f"+{score}", False, "Black")
        text_rect = text_score.get_rect(midtop = (coord_x + 23, coord_y + 5))
        self.screen.blit(text_score, text_rect)


    coord_x = self.delta_x - 100
    coord_y = self.delta_y + self.size - 8*self.cell_size
    white_pawn_rect = self.white_pawn_surface2.get_rect(midtop = (coord_x, coord_y))
    self.screen.blit(self.white_pawn_surface2, white_pawn_rect)
    text_white_pawn_taken = self.font_pieces_taken.render(f"x{self.pieces_taken_by_black.count('')}", False, "Black")
    text_rect = text_white_pawn_taken.get_rect(midtop = (coord_x + 23, coord_y + 5))
    self.screen.blit(text_white_pawn_taken, text_rect)

    coord_x += 55
    white_knight_rect = self.white_knight_surface2.get_rect(midtop = (coord_x, coord_y))
    self.screen.blit(self.white_knight_surface2, white_knight_rect)
    text_white_knight_taken = self.font_pieces_taken.render(f"x{self.pieces_taken_by_black.count('N')}", False, "Black")
    text_rect = text_white_knight_taken.get_rect(midtop = (coord_x + 23, coord_y + 5))
    self.screen.blit(text_white_knight_taken, text_rect)

    coord_x = self.delta_x - 100
    coord_y = self.delta_y + self.size - 7.5*self.cell_size
    white_bishop_rect = self.white_bishop_surface2.get_rect(midtop = (coord_x, coord_y))
    self.screen.blit(self.white_bishop_surface2, white_bishop_rect)
    text_white_bishop_taken = self.font_pieces_taken.render(f"x{self.pieces_taken_by_black.count('B')}", False, "Black")
    text_rect = text_white_bishop_taken.get_rect(midtop = (coord_x + 23, coord_y + 5))
    self.screen.blit(text_white_bishop_taken, text_rect)

    coord_x += 55
    white_rook_rect = self.white_rook_surface2.get_rect(midtop = (coord_x, coord_y))
    self.screen.blit(self.white_rook_surface2, white_rook_rect)
    text_white_rook_taken = self.font_pieces_taken.render(f"x{self.pieces_taken_by_black.count('R')}", False, "Black")
    text_rect = text_white_rook_taken.get_rect(midtop = (coord_x + 23, coord_y + 5))
    self.screen.blit(text_white_rook_taken, text_rect)

    coord_x = self.delta_x - 100
    coord_y = self.delta_y + self.size - 7*self.cell_size
    white_queen_rect = self.white_queen_surface2.get_rect(midtop = (coord_x, coord_y))
    self.screen.blit(self.white_queen_surface2, white_queen_rect)
    text_white_queen_taken = self.font_pieces_taken.render(f"x{self.pieces_taken_by_black.count('Q')}", False, "Black")
    text_rect = text_white_queen_taken.get_rect(midtop = (coord_x + 23, coord_y + 5))
    self.screen.blit(text_white_queen_taken, text_rect)


    if score == 1000000 or score == -1000000:
        coord_x += 45
        text_score = self.font_pieces_taken.render("#", False, "Black")
        text_rect = text_score.get_rect(midtop = (coord_x + 23, coord_y + 5))
        self.screen.blit(text_score, text_rect)
    elif score < 0:
        coord_x += 45
        text_score = self.font_pieces_taken.render(f"+{-score}", False, "Black")
        text_rect = text_score.get_rect(midtop = (coord_x + 23, coord_y + 5))
        self.screen.blit(text_score, text_rect)

def display_restart_button(self):
    font_restart = pygame.font.Font(None, 27)
    coord_x = self.delta_x - 75
    coord_y = self.delta_y + self.size//2 - 20
    text_restart = font_restart.render("Recommencer", False, "Black")
    text_rect = text_restart.get_rect(center = (coord_x, coord_y))
    rect_restart = pygame.Rect(self.delta_x - 143, coord_y - 15, 135, 30)
    pygame.draw.rect(self.screen, "Gray", rect_restart)
    self.screen.blit(text_restart, text_rect)

 def display_who_to_play(self):
    self.remove_text()
    if self.IsWhiteToPlay:
        text_white_to_play = self.font.render("Au tour des Blancs", False, "Black")
        text_rect = text_white_to_play.get_rect(center = (self.size//2 + self.delta_x, self.delta_y//2))
        self.screen.blit(text_white_to_play, text_rect)
    else:
        text_black_to_play = self.font.render("Au tour des Noirs", False, "Black")
        text_rect = text_black_to_play.get_rect(center = (self.size//2 + self.delta_x, self.delta_y//2))
        self.screen.blit(text_black_to_play, text_rect)

def display_winner(self, is_white_winner):
    self.remove_text()
    if is_white_winner:
        text_white_winner = self.font.render("Les Blancs ont gagn√© !", False, "Black")
        text_rect = text_white_winner.get_rect(center = (self.size//2 + self.delta_x, self.delta_y//2))
        self.screen.blit(text_white_winner, text_rect)
    if not is_white_winner:
        text_black_winner = self.font.render("Les Noirs ont gagn√© !", False, "Black")
        text_rect = text_black_winner.get_rect(center = (self.size//2 + self.delta_x, self.delta_y//2))
        self.screen.blit(text_black_winner, text_rect)

def display_moves(self):
    self.remove_moves()
    delta_move_x = 100
    delta_move_y = 10
    if len(self.move_list) > self.limit * 2:
        max_scroll_count = math.ceil(len(self.move_list)/2) * 2 - self.limit * 2
        if (-1 * self.scroll_count * 2) == max_scroll_count or not self.scrolled:
            list_move_to_display = self.move_list[max_scroll_count:]
            if len(list_move_to_display) % 2 == 1:
                list_move_to_display.append(["", ""])
        else:
            index_start = - self.scroll_count * 2
            index_end = index_start + self.limit * 2
            list_move_to_display = self.move_list[index_start:index_end]
    else:
        list_move_to_display = self.move_list[:]
        self.scroll_count = 0
    for k in range(len(list_move_to_display)):
        coord_y = self.delta_y + (k // 2) * self.font_moves_size + delta_move_y
        if k % 2 == 0:
            coord_x = self.delta_x + self.size + delta_move_x
            text_move = self.font_moves.render(list_move_to_display[k][1], False, "Black")
            text_rect = text_move.get_rect(center = (coord_x, coord_y))
            self.screen.blit(text_move, text_rect)

            coord_x2 = self.delta_x + self.size + delta_move_x - 50
            text_move2 = self.font_moves.render(str(list_move_to_display[k][0]) + ".", False, "Black")
            text_rect2 = text_move2.get_rect(center = (coord_x2, coord_y))
            self.screen.blit(text_move2, text_rect2)
        if k % 2 == 1:
            coord_x = self.delta_x + self.size + delta_move_x + 70
            text_move = self.font_moves.render(list_move_to_display[k][1], False, "Black")
            text_rect = text_move.get_rect(center = (coord_x, coord_y))
            self.screen.blit(text_move, text_rect)


</code></pre></div>
</details>
</div>
<h3 id="affichage-des-mouvements-possibles" tabindex="-1"><a class="header-anchor" href="#affichage-des-mouvements-possibles"></a> Affichage des mouvements possibles</h3>
<p>Il faut √† pr√©sent cr√©er une m√©thode qui permet d'afficher les cases o√π la pi√®ce s√©lectionn√©e peut aller. Il faut d'abord d√©terminer quelle case a √©t√© s√©lectionn√©e par l'utilisateur. Pour cela, on utilise la m√©thode <em>get_row_column</em> qui renvoie le num√©ro de ligne et colonne de la case s√©lectionn√©e par le joueur.</p>
<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100 cursor-pointer select-none dark:border-indigo-800 dark:bg-indigo-950">
<details class="group">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 fill-none stroke-2 stroke-indigo-500 dark:stroke-indigo-800" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 fill-none stroke-2 stroke-indigo-500 dark:stroke-indigo-800" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block group-open:select-text">
<p>Cliquer pour voir la m√©thode <em>get_row_column</em></p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 fill-none stroke-2 stroke-indigo-500 dark:stroke-indigo-800" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2 cursor-auto select-text">
<pre class="language-python line-numbers"><code>

def get_row_column(self):
    pos = pygame.mouse.get_pos()
    pos_x = pos[0] - self.delta_x
    pos_y = pos[1] - self.delta_y
    if (pos_x in range(0, self.size + 1)) and (pos_y in range(0, self.size + 1)):
        nb_row = 7 - (pos_y // self.cell_size)
        nb_column = pos_x // self.cell_size
        return(nb_row, nb_column)
    else:
        return(None)


</code></pre></div>
</details>
</div>
<p>Ensuite, il faut r√©cup√©rer l'attribut <em>possible_moves</em> qui est a √©t√© d√©fini plus t√¥t, et qui contient toutes les cases possibles sur lesquelles chaque pi√®ce peut aller. On peut ainsi r√©cup√©rer les num√©ros de lignes et colonnes de chaque cases, et ainsi les colorer de la bonne couleur. Notons que c'est dans cette m√©thode que l'on g√®re la prise en passant.</p>
<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100 cursor-pointer select-none dark:border-indigo-800 dark:bg-indigo-950">
<details class="group">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 fill-none stroke-2 stroke-indigo-500 dark:stroke-indigo-800" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 fill-none stroke-2 stroke-indigo-500 dark:stroke-indigo-800" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block group-open:select-text">
<p>Cliquer pour voir le code de la m√©thode <em>update_cells_selected</em></p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 fill-none stroke-2 stroke-indigo-500 dark:stroke-indigo-800" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2 cursor-auto select-text">
<pre class="language-python line-numbers"><code>

def update_cells_selected(self, piece):
    valid_moves = []
    current_cell = copy.deepcopy(piece.current_cell)
    initial_board = copy.deepcopy(self.board[:])
    if self.en_passant_cell != None and piece.letter == "":
        adjacent_column1 = self.en_passant_cell.column - 1
        adjacent_column2 = self.en_passant_cell.column + 1
        if piece.current_cell.column in [adjacent_column1, adjacent_column2]:
            if piece.current_cell.row + 1 == self.en_passant_cell.row and piece.IsWhite:
                piece.en_passant = self.en_passant_cell
                piece.possible_moves.append(self.en_passant_cell)
                valid_moves.append(self.en_passant_cell)
            elif piece.current_cell.row - 1 == self.en_passant_cell.row and not piece.IsWhite:
                piece.en_passant = self.en_passant_cell
                piece.possible_moves.append(self.en_passant_cell)
                valid_moves.append(self.en_passant_cell)
    for cell in piece.possible_moves:
        if cell.short_castle:
            if self.IsWhiteToPlay:
                row = 0
            else:
                row = 7
            if not self.IsCheck(self.IsWhiteToPlay):
                self.move(current_cell, Cell(row, 5))
                if not self.IsCheck(self.IsWhiteToPlay):
                    self.board = copy.deepcopy(initial_board)
                    self.move(current_cell, Cell(row, 6))
                    if not self.IsCheck(self.IsWhiteToPlay):
                        valid_moves.append(copy.deepcopy(cell))
                        self.board = copy.deepcopy(initial_board)
                    else:
                        self.board = copy.deepcopy(initial_board)
                else:
                    self.board = copy.deepcopy(initial_board)
        elif cell.long_castle:
            if self.IsWhiteToPlay:
                row = 0
            else:
                row = 7
            if not self.IsCheck(self.IsWhiteToPlay):
                self.move(current_cell, Cell(row, 2))
                if not self.IsCheck(self.IsWhiteToPlay):
                    self.board = copy.deepcopy(initial_board)
                    self.move(current_cell, Cell(row, 3))
                    if not self.IsCheck(self.IsWhiteToPlay):
                        valid_moves.append(copy.deepcopy(cell))
                        self.board = copy.deepcopy(initial_board)
                    else:
                        self.board = copy.deepcopy(initial_board)
                else:
                    self.board = copy.deepcopy(initial_board)
        else:
            self.move(current_cell, cell)
            if not self.IsCheck(self.IsWhiteToPlay):
                valid_moves.append(copy.deepcopy(cell))
            self.board = copy.deepcopy(initial_board)
    self.cells_selected = [piece.current_cell, copy.deepcopy(valid_moves)]


</code></pre></div>
</details>
</div>
<h3 id="test-du-programme" tabindex="-1"><a class="header-anchor" href="#test-du-programme"></a> Test du programme</h3>
<p>Voici quelques captures d'√©cran de ce que le programme produit:</p>
<p><img src="https://raw.githubusercontent.com/do-it-ecm/promo-2023-2024/refs/heads/main//Dang-Vu-Duc/pok/temps-2/Image5.png" alt="Image partie normale">
<em>Image d'une partie en cours, avec une pi√®ce s√©lectionn√©e</em></p>
<p><img src="https://raw.githubusercontent.com/do-it-ecm/promo-2023-2024/refs/heads/main//Dang-Vu-Duc/pok/temps-2/Image6.png" alt="Image √©chec">
<em>Image d'une situation d'√©chec par les Blancs</em></p>
<p><img src="https://raw.githubusercontent.com/do-it-ecm/promo-2023-2024/refs/heads/main//Dang-Vu-Duc/pok/temps-2/Image7.png" alt="Image √©chec et mat">
<em>Image d'une situation de fin de partie (√©chec et mat)</em></p>
<h2 id="bilan-du-deuxi%C3%A8me-sprint" tabindex="-1"><a class="header-anchor" href="#bilan-du-deuxi%C3%A8me-sprint"></a> Bilan du deuxi√®me sprint</h2>
<p>Tout les √©l√©ments du backlog ont √©t√© r√©alis√©s, except√© la fonctionnalit√© du retournement de plateau. En effet, j'ai largement sous-estim√© la difficult√© de cette fonctionnalit√©, car elle implique d'inverser toutes les coordonn√©es pr√©sentes dans le code et cela prendrait un temps consid√©rable.</p>



</article>

        </main>

        <footer class="min-h-[50px] border-t-2 mt-4 border-gray-200 dark:border-neutral-700">
            <div class="max-w-[1000px] mx-auto px-4">
                <div class="min-h-[50px] flex justify-center items-center">
                    <p class="text-center">
                        ¬©2025 <b><span style="font-family: Consolas, sans-serif;">Do-<span style="color: #4a86e8">It</span></span></b> - D√©veloppement, Management et Gestion de projets en IT
                    </p>
                </div>
            </div>
        </footer>

        <!-- MathJax import and initialization -->
        <script src="https://cdn.jsdelivr.net/npm/mathjax/es5/tex-svg-full.js" defer="">
            window.MathJax = {
                tex: {
                    inlineMath: [['$', '$'], ['\\(', '\\)']], // Delimiters for inline math
                    displayMath: [['$$', '$$'], ['\\[', '\\]']] // Delimiters for block math
                },
                svg: {
                    fontCache: 'global' // Use global font cache for SVG output
                }
            };
            document.addEventListener('DOMContentLoaded', () => {
                MathJax.typeset(); // Ensures MathJax processes the content after the page loads
            });
        </script>

        <script src="https://cdn.jsdelivr.net/npm/prismjs/prism.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/toolbar/prism-toolbar.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/normalize-whitespace/prism-normalize-whitespace.min.js">
            Prism.plugins.NormalizeWhitespace.setDefaults({
                'remove-trailing': true,
                'remove-indent': true,
                'left-trim': true,
                'right-trim': true,
            });
        </script>
        <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/show-language/prism-show-language.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/autoloader/prism-autoloader.min.js"></script>
    </body>
</html>
