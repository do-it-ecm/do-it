<!doctype html><html lang="fr"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="robots" content="index, follow"><link rel="canonical" href="https://do-it.aioli.ec-m.fr/promos/2023-2024/Vietor-Paul/mon/temps-1.2/"><meta name="description" content="Une introduction au langage Rust au travers du livre Rust officiel."><meta property="og:description" content="Une introduction au langage Rust au travers du livre Rust officiel."><meta name="twitter:description" content="Une introduction au langage Rust au travers du livre Rust officiel."><meta name="author" content="Paul Vietor"><meta name="keywords" content="do-it, centrale, centrale m√©diterran√©e, ecm, MON, Rust"><link rel="icon" href="https://raw.githubusercontent.com/do-it-ecm/do-it/main/src/assets/img/logo/favicon.ico" type="image/x-icon"><link rel="icon" href="https://raw.githubusercontent.com/do-it-ecm/do-it/main/src/assets/img/logo/minimal.png" type="image/png"><link rel="apple-touch-icon" href="https://raw.githubusercontent.com/do-it-ecm/do-it/main/src/assets/img/logo/minimal.png"><link href="/assets/stylesheets/main.css" rel="stylesheet"><meta property="og:title" content="Introduction au langage Rust"><meta property="og:image" content="https://raw.githubusercontent.com/do-it-ecm/do-it/main/src/assets/img/logo/intermediate-text.png"><meta property="og:url" content="https://do-it.aioli.ec-m.fr/promos/2023-2024/Vietor-Paul/mon/temps-1.2/"><meta property="og:type" content="website"><meta name="twitter:card" content="https://raw.githubusercontent.com/do-it-ecm/do-it/main/src/assets/img/logo/intermediate-text.png"><meta name="twitter:title" content="Introduction au langage Rust"><meta name="twitter:image" content="https://raw.githubusercontent.com/do-it-ecm/do-it/main/src/assets/img/logo/intermediate-text.png"><meta name="twitter:url" content="https://do-it.aioli.ec-m.fr/promos/2023-2024/Vietor-Paul/mon/temps-1.2/"><title>Introduction au langage Rust</title><link href="https://cdn.jsdelivr.net/npm/prismjs/plugins/toolbar/prism-toolbar.min.css" rel="stylesheet"><link id="prism-theme" href="https://cdn.jsdelivr.net/npm/prismjs/themes/prism-solarizedlight.min.css" rel="stylesheet"><link href="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet"><script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script><script defer="">const storedTheme=localStorage.getItem("theme");function loadPrismTheme(e){const t=e?"prism-okaidia.min.css":"prism-solarizedlight.min.css",s=document.createElement("link");s.rel="stylesheet",s.id="prism-theme",s.href=`https://cdn.jsdelivr.net/npm/prismjs/themes/${t}`,s.onload=()=>{Prism.highlightAll()};const m=document.getElementById("prism-theme");m?document.head.replaceChild(s,m):document.head.appendChild(s)}function setMermaidTheme(e){const t=e?"dark":"forest";mermaid.initialize({securityLevel:"loose",theme:t,startOnLoad:!0})}function toggleDarkMode(){const e=document.documentElement.classList.contains("dark"),t=e?"light":"dark";localStorage.setItem("theme",t),document.documentElement.classList.toggle("dark",!e),loadPrismTheme(!e),setMermaidTheme(!e)}storedTheme?document.documentElement.classList.toggle("dark","dark"===storedTheme):document.documentElement.classList.toggle("dark",window.matchMedia("(prefers-color-scheme: dark)").matches);const isDark=document.documentElement.classList.contains("dark");loadPrismTheme(isDark),setMermaidTheme(isDark)</script></head><body data-prismjs-copy="üìã" data-prismjs-copy-error="‚ùå" data-prismjs-copy-success="‚úÖ" data-prismjs-copy-timeout="1000" class="bg-neutral-50 text-neutral-950 dark:bg-neutral-900 dark:text-neutral-50"><header class="fixed top-0 z-50 w-full border-b-2 border-gray-200 bg-white dark:bg-neutral-900 dark:border-neutral-700"><div class="max-w-[1000px] mx-auto px-4"><div class="min-h-[50px] flex justify-between items-center"><a class="mx-2" href="/">Home</a> <button class="hidden sm:block text-neutral-950 dark:text-neutral-50 hover:bg-neutral-700 hover:text-neutral-50 hover:dark:bg-neutral-300 hover:dark:text-neutral-950 transition-colors p-2 rounded-full duration-800 ease-in-out" onclick="toggleDarkMode()"><svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="h-5 aspect-square fill-none aspect-square stroke-2 dark:hidden stroke-current"><circle cx="12" cy="12" r="5"></circle><path d="M12 2V4" stroke-linecap="round"></path><path d="M12 20V22" stroke-linecap="round"></path><path d="M4 12L2 12" stroke-linecap="round"></path><path d="M22 12L20 12" stroke-linecap="round"></path><path d="M19.7778 4.22266L17.5558 6.25424" stroke-linecap="round"></path><path d="M4.22217 4.22266L6.44418 6.25424" stroke-linecap="round"></path><path d="M6.44434 17.5557L4.22211 19.7779" stroke-linecap="round"></path><path d="M19.7778 19.7773L17.5558 17.5551" stroke-linecap="round"></path></svg> <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="h-5 aspect-square fill-none aspect-square stroke-2 stroke-current hidden dark:block"><path d="M3.32031 11.6835C3.32031 16.6541 7.34975 20.6835 12.3203 20.6835C16.1075 20.6835 19.3483 18.3443 20.6768 15.032C19.6402 15.4486 18.5059 15.6834 17.3203 15.6834C12.3497 15.6834 8.32031 11.654 8.32031 6.68342C8.32031 5.50338 8.55165 4.36259 8.96453 3.32996C5.65605 4.66028 3.32031 7.89912 3.32031 11.6835Z" stroke-linecap="round" stroke-linejoin="round"></path></svg></button><div class="flex items-center gap-4 sm:gap-6"><a class="" href="/cs">CS</a> <a class="" href="/pok">POK</a> <a class="" href="/mon">MON</a> <a class="" href="/projets">Projets</a> <a class="hidden sm:block" href="/promos">Promos</a> <a href="/search"><svg class="h-5 aspect-square stroke-neutral-950 dark:stroke-neutral-300 fill-none stroke-2" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607z"></path></svg> </a><a class="hidden sm:block" href="https://github.com/do-it-ecm/do-it" target="_blank"><svg class="h-5 aspect-square dark:stroke-neutral-300 dark:fill-neutral-300" role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>GitHub</title><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"></path></svg></a></div></div></div></header><main class="mt-[66px] max-w-[1000px] mx-auto px-4" data-pagefind-body=""><article class="relative"><h1 class="mb-1">Introduction au langage Rust</h1><div class="mb-4"><div class="px-4 flex flex-wrap items-center"><div class="font-bold">Tags :</div><ul class="flex flex-wrap overflow-auto not-prose list-none my-1 mx-0 px-1 gap-1" data-pagefind-meta="Tags"><li class="bg-yellow-200 rounded-full px-2 text-neutral-950" data-pagefind-filter="Tags">MON</li><li class="bg-yellow-200 rounded-full px-2 text-neutral-950" data-pagefind-filter="Tags">Rust</li></ul><div class="hidden" data-pagefind-meta="Type" aria-hidden="true"><span data-pagefind-filter="Type">MON</span></div></div><div class="px-4 flex flex-wrap items-center"><div class="font-bold">Auteur :</div><ul class="flex flex-wrap not-prose list-none my-1 mx-0 px-1 gap-1" data-pagefind-meta="Auteurs"><li class="bg-blue-200 rounded-full px-2 text-neutral-950" data-pagefind-filter="Auteurs">Paul Vietor</li></ul></div><div class="absolute top-0 right-0"><span class="bg-purple-200 rounded-full px-3 py-1 mt-2 mr-2 text-neutral-950" data-pagefind-filter="Ann√©e">2023-2024</span></div></div><p class="mb-4 text-lg">Une introduction au langage Rust au travers du livre Rust officiel.</p><div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-purple-500 bg-purple-100 dark:border-purple-800 dark:bg-purple-950"><svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 fill-none stroke-2 stroke-purple-500 dark:stroke-purple-800" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M5 19a2 2 0 01-2-2V7a2 2 0 012-2h4l2 2h4a2 2 0 012 2v1M5 19h14a2 2 0 002-2v-5a2 2 0 00-2-2H9a2 2 0 00-2 2v5a2 2 0 01-2 2z"></path></svg><div class="pl-8 mr-8"><a href="/promos/2023-2024/Vietor-Paul/">Paul Vietor</a><span class="px-1">/</span><a href="/promos/2023-2024/Vietor-Paul/mon/">MON de Paul Vietor</a><span class="px-1">/</span><a href="/promos/2023-2024/Vietor-Paul/mon/temps-1.2/">Introduction au langage Rust</a></div></div><h2 id="introduction" tabindex="-1"><a class="header-anchor" href="#introduction"></a> Introduction</h2><p>Dans ce second MON, j'ai d√©cid√© de me lancer dans le langage Rust en parcourant le <a href="https://doc.rust-lang.org/stable/book/title-page.html">livre de Rust</a>, en faisant les quelques projets qui y sont propos√©s au cours de sa lecture.</p><p>Mais, me demanderez-vous, qu'est-ce que Rust ?</p><h2 id="pr%C3%A9sentation-du-langage-rust" tabindex="-1"><a class="header-anchor" href="#pr%C3%A9sentation-du-langage-rust"></a> Pr√©sentation du langage Rust</h2><p>D'apr√®s <a href="https://fr.wikipedia.org/wiki/Rust_(langage)">Wikip√©dia</a>, &quot;Rust est un langage de programmation compil√© multi-paradigme con√ßu et d√©velopp√© par Mozilla Research depuis 2010.&quot;... Ouais. √áa ne nous avance pas beaucoup, et m√™me si le reste de la page nous donne de plus amples explications, c'est un peu long pour tout citer ici, donc je vais me contenter des grandes propri√©t√©s importantes :</p><ul><li>Tout d'abord, reprenons les deux termes cit√©s ci-dessus :<ul><li>Rust est compil√© : on √©crit du code en Rust, puis on le donne √† un compilateur qui va lui nous donner un ex√©cutable, un fichier en langage machine que le processeur pourra directement utiliser. Il est en cela similaire √† des langages tels que le C, le C++, l'OCaml, et bien d'autres, et s'oppose par exemple aux langages Bash et Perl.</li><li>Rust est multi-paradigme : en programmation, un paradigme est, grossi√®rement, l'approche utilis√©e par un langage pour d√©crire le programme. En programmation dite imp√©rative (C, Python...), un programme est une suite d'instructions que doit ex√©cuter le processeur. En programmation fonctionnelle (OCaml, Haskell), un programme est une cha√Æne d'√©valuations de fonctions. Enfin, pour ne citer que trois exemples, en programmation orient√©e (Java, C#...), un programme consiste en un ensemble d'&quot;objets&quot;, des sortes de briques du programme, qui interagissent entre eux. Dans les faits, tr√®s peu de langages modernes se restreignent √† un seul de ces paradigmes, et en ce qui concerne Rust, c'est un langage principalement imp√©ratif et fonctionnel, qui int√®gre quelques notions de la programmation orient√©e objet.</li></ul></li><li>Rust est de plus un langage fortement typ√© : chaque variable a un type qui d√©finit les op√©rations que l'on peut faire sur cette variable, et il est interdit de changer implicitement le type d'une variable. Par exemple, on ne peut pas additionner une variable enti√®re et un nombre √† virgule flottante ou une cha√Æne de caract√®re (√† moins de ne d√©finir explicitement l'op√©ration nous-m√™me), contrairement √† ce qui est possible en JavaScript, qui acceptera volontiers de dire que la cha√Æne de caract√®re <code>&quot;Hello&quot;</code> √† laquelle on additionnerait le nombre <code>2.718</code> nous donne... la cha√Æne de caract√®re <code>&quot;Hello2.718&quot;</code>.</li><li>Il est √©galement statiquement typ√© : √† chaque variable est associ√© un unique type, et on ne peut pas lui assigner une valeur d'un type diff√©rent.</li><li>Enfin, sa syntaxe est similaire √† celle du C (et du C++, de JavaScript...), avec l'utilisation d'accolades pour d√©finir des blocs de code, de parenth√®ses pour d√©finir les arguments de ses fonction, les points-virgules en fin de ligne... avec quelques diff√©rences, notamment au niveau de la d√©claration du type d'une variable, qui se trouve apr√®s le nom de la variable.</li></ul><h2 id="en-quoi-consiste-le-livre-de-rust" tabindex="-1"><a class="header-anchor" href="#en-quoi-consiste-le-livre-de-rust"></a> En quoi consiste le livre de Rust</h2><p>La communaut√© Rust a √©crit un livre √† destination de ceux d√©sirant apprendre le langage Rust. En une vingtaine de chapitres (trop pour que je puisse le finir en 10h), il nous pr√©sente les fonctionnalit√©s du langage Rust, et nous accompagne dans 3 projets : un tr√®s simple jeu dans lequel le joueur doit deviner un nombre al√©atoire entre 1 et 100, d√®s le chapitre 2, un clone minimaliste du programme <code>grep</code>, qui permet de rechercher une cha√Æne de caract√®res dans un fichier, au chapitre 12, et enfin un serveur web <em>multithread√©</em>, c'est-√†-dire qui ex√©cute plusieurs t√¢ches en parral√®le sur diff√©rents <em>threads</em> du processeur, au chapitre 20.</p><p>Tout d'abord, le premier chapitre est d√©di√© √† l'installation des outils n√©cessaires au d√©veloppement en Rust, et le deuxi√®me chapitre nous guide au travers du premier projet. Ensuite, les chapitres 3 √† 10 nous pr√©sentent les fonctionnalit√©s et sp√©cificit√©s essentielles du langage : les types et structures de donn√©es de base disponibles, les biblioth√®ques (nomm√©es <em>crates</em>), la gestion des erreurs, et, bien s√ªr, la sp√©cificit√© incontournable de Rust, la notion de propri√©t√©, reprise plus en d√©tail par Assane Diouf dans son <a href="/promos/2023-2024/Diouf-Asssane/mon/Rust">premier MON</a>. Le chapitre 11, quant √† lui, nous pr√©sente les fonctionnalit√©s de tests automatiques qui pourront √™tre ex√©cut√©s par <code>cargo</code>, l'outil principal de gestion des projets Rust, afin de nous pr√©parer au deuxi√®me projet, au chapitre 12. Enfin, les chapitres 13 √† 19 nous pr√©sentent les fonctionnalit√©s avanc√©es de Rust afin de nous pr√©parer au dernier projet du chapitre 20, √† l'exception du chapitre 14 qui revient sur <code>cargo</code> ainsi que la gestion des <em>crates</em> et <a href="https://crates.io/">Crates.io</a>, le site officiel pour trouver des <em>crates</em>.</p><p>Pour ce MON, je vais donc tenter d'expliquer de fa√ßon succinte les divers concepts rencontr√©s dans ce livre au fil de ma lecture, chapitre par chapitre, jusqu'au point auquel j'aurai r√©ussi √† arriver en dix heures.</p><h2 id="mon-avancement-dans-la-lecture-du-livre" tabindex="-1"><a class="header-anchor" href="#mon-avancement-dans-la-lecture-du-livre"></a> Mon avancement dans la lecture du livre</h2><h3 id="chapitre-1-%3A-outils-et-installation" tabindex="-1"><a class="header-anchor" href="#chapitre-1-%3A-outils-et-installation"></a> Chapitre 1 : Outils et installation</h3><p>Le chapitre 1 √©tait tr√®s rapide, puisqu'il n'a √©t√© pour moi que l'affaire de lancer quelques commandes et attendre que les t√©l√©chargements se fassent.</p><h3 id="chapitre-2-%3A-premier-projet" tabindex="-1"><a class="header-anchor" href="#chapitre-2-%3A-premier-projet"></a> Chapitre 2 : Premier projet</h3><p>Le chapitre 2 m'a pris environ une heure et demi pour tout bien comprendre. Ce chapitre sert d'introduction √† plusieurs concepts que nous verrons plus en profondeur dans les chapitres suivants :</p><ul><li>Les variables mutables/non-mutables</li><li>Les r√©f√©rences</li><li>Les entr√©es/sorties sur l'invite de commandes</li><li>L'√©num√©ration <code>Result</code> pour d√©crire le succ√®s ou l'√©chec d'une op√©ration</li><li>Les erreurs de compilation</li><li>Le <code>match</code></li><li>La gestion des d√©pendances</li></ul><h3 id="chapitre-3-%3A-notions-communes-en-programmation" tabindex="-1"><a class="header-anchor" href="#chapitre-3-%3A-notions-communes-en-programmation"></a> Chapitre 3 : Notions communes en programmation</h3><p>Le chapitre 3, rapide √† lire quand on a d√©j√† des bases de programmation, pr√©sente des notions communes √† la tr√®s grande majorit√© des langages de programmation : les variables, les types de donn√©es, les fonctions, les commentaires et les structures de contr√¥le (<em>control flow</em>). On y d√©couvre quelques sp√©cificit√©s de Rust :</p><ul><li>Il existe 3 classes de variables diff√©rents : non-mutable, d√©clar√©e avec <code>let</code>, mutable, d√©clar√©e avec <code>let mut</code> et constante, d√©clar√©e avec <code>const</code>. Les variables mutables peuvent recevoir pendant l'ex√©cution du programme une valeur diff√©rente de leur valeur initiale, mais de m√™me type, contrairement aux variables non-mutables ou constantes qui gardent la m√™me valeur. De plus, la valeur d'une variable constance doit √™tre connue au moment de la compilation. On nous pr√©sente √©galement le <em>shadowing</em> de variable, quand on d√©clare une nouvelle variable avec le m√™me nom qu'un variable pr√©-existante, qui permet de garder le nom de la variable mais d'en changer le type, par exemple.</li><li>Les caract√®res sont repr√©sent√©s sur 4 octets et contiennent un caract√®re Unicode.</li><li>Une fonction peut renvoyer la valeur d'une expression qu'elle contient sans avoir besoin de <code>return</code> explicite, mais il est √©galement possible d'utiliser <code>return</code>.</li><li>Quand on √©value une condition, par exemple dans un <code>if</code>, il faut obligatoirement que la condition √† √©valuer soit un bool√©en : on ne peut pas faire <code>if 3 {}</code>, par exemple, l√† o√π en C, Python, et la plupart des autres langages, le 3 serait implicitement converti en le bool√©en <code>true</code>.</li></ul><h3 id="chapitre-4-%3A-la-propri%C3%A9t%C3%A9" tabindex="-1"><a class="header-anchor" href="#chapitre-4-%3A-la-propri%C3%A9t%C3%A9"></a> Chapitre 4 : La propri√©t√©</h3><p>Le chapitre 4 est le chapitre qui pr√©sente la notion de propri√©t√©, et peut √™tre long √† comprendre puisque qu'il explique la gestion de la m√©moire en Rust. J'en ai personnellement eu pour deux petites heures, en ayant d√©j√† rencontr√© certaines notions abord√©es dans ce chapitre. Je ne reviendrai pas sur la notion de propri√©t√© sp√©cifiquement, puisque ce serait une redite de ce qu'a d√©j√† expliqu√© Assane dans son MON. Cependant, je peux expliquer la gestion de la m√©moire : en Rust, les donn√©es peuvent aller √† deux endroits :</p><ul><li>La <strong>pile</strong> (<em>stack</em>), pour les valeurs de types de taille constante (un nombre, un caract√®re) et, g√©n√©ralement, r√©duite</li><li>Le <strong>tas</strong> (<em>heap</em>), pour les valeurs de types de taille variable (les cha√Ænes de caract√®res) ou les valeurs qui sont particuli√®rement grandes. Quand on cr√©e une variable de type, par exemple, <code>i32</code> (un nombre entier entre -2¬≥¬π et 2¬≥¬π-1), qui est de taille constante (32 bits), Rust met sa valeur sur le haut de la pile. Cette variable est ainsi particuli√®rement rapide d'acc√®s et peut √™tre copi√©e et transf√©r√©e tr√®s rapidement. Quand on cr√©e une cha√Æne de caract√®res, par contre, Rust va allouer une certaine quantit√© de m√©moire sur le tas dans laquelle il va enregistrer les caract√®res, et mettre sur la pile une valeur de taille fix√©e qui contient l'emplacement sur le tas de la cha√Æne de caract√®re, et quelques informations sur la cha√Æne de caract√®res : sa longueur, et la place disponible pour cette cha√Æne de caract√®res sur le tas.</li></ul><p>La distinction est importante car, quand on assigne une valeur √† une variable, on assigne seulement la valeur qui se trouve sur la pile. Ainsi, si on d√©clare deux entiers, <code>a</code> et <code>b</code>, puis que l'on fait <code>b = a</code>, b est une copie ind√©pendante de a, et on peut modifier b sans affecter la valeur de a (pour peu que b soit mutable, √©videmment). Cependant, si on essaye de faire la m√™me chose avec deux cha√Ænes de caract√®res, b ne va copier que la valeur de a se trouvant sur la pile : l'emplacement sur le tas, la longueur et la place disponible. Les deux variables pointeront donc aux m√™me donn√©es sur le tas, et toute modification √† b modifierait a, et inversement. Pour √©viter de faire cette erreur, Rust rend alors a invalide : on ne peut plus l'utiliser, sous peine de causer une erreur √† la compilation. Si on veut r√©ellement copier a dans une nouvelle variable, il faut le faire explicitement avec la m√©thode <code>clone()</code>.</p><div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-cyan-500 bg-cyan-100 dark:border-cyan-800 dark:bg-cyan-950"><svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 fill-none stroke-2 stroke-cyan-500 dark:stroke-cyan-800" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path></svg><div class="pl-8 mb-2 mr-8"><p><b>Information</b></p></div><div class="pl-8 mr-8"><p>La fa√ßon dont Rust d√©termine le comportement √† adopter en pratique implique le <strong>trait</strong> Copy, mais les traits √©tant seulement au programme du chapitre 10, il ne me semblait pas int√©ressant d'en parler ici.</p></div></div><h3 id="chapitre-5-%3A-structures" tabindex="-1"><a class="header-anchor" href="#chapitre-5-%3A-structures"></a> Chapitre 5 : Structures</h3><p>Le chapitre 5 pr√©sente les structures (<code>struct</code>s), en opposition aux uplets (<em>tuples</em>), d√©crits dans le chapitre 3. Les deux permettent de stocker plusieurs valeurs dans une m√™me variables, mais dans une structure, chacune de ces valeurs peut avoir un nom, et une structure est en soi un type de donn√©es nomm√©, dont le nom est donn√© par le programmeur. Cela permet alors de passer des structures comme arguments √† nos fonctions, rendant le code plus clair, et de d√©finir des <strong>m√©thodes</strong> pour les structures.</p><div class="quote relative drop-shadow py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100 dark:border-amber-800 dark:bg-amber-950"><svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 fill-none stroke-2 stroke-amber-800 dark:stroke-amber-800" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg><div class="pl-8 mb-2 mr-8"><p><b>Note</b></p></div><div class="pl-8 mr-8"><p>Pour impl√©menter une m√©thode pour notre structure, il faut utiliser un bloc <code>impl</code> dans lequel on met nos m√©thodes, s√©par√© du bloc <code>struct</code> d√©finissant la structure.</p></div></div><div class="quote relative drop-shadow py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100 dark:border-amber-800 dark:bg-amber-950"><svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 fill-none stroke-2 stroke-amber-800 dark:stroke-amber-800" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg><div class="pl-8 mb-2 mr-8"><p><b>Note</b></p></div><div class="pl-8 mr-8"><p>Il est √©galement possible de cr√©er des structures ne stockant aucune valeur, on a alors un type dit unit√© (et de m√™me pour les uplets, on peut cr√©er le 0-uplet <code>()</code> qui ne contient aucune valeur). Cela peut √©galement avoir des int√©r√™ts, mais qu'on ne verra pas avant le chapitre 10.</p></div></div><p>Ainsi, ce chapitre nous montre comment utiliser une structure pour repr√©senter un rectangle, et d√©finit quelques m√©thodes sur ces rectangles : le calcul de leur aire, et savoir si un rectangle rentre dans un autre.</p><div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-cyan-500 bg-cyan-100 dark:border-cyan-800 dark:bg-cyan-950"><svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 fill-none stroke-2 stroke-cyan-500 dark:stroke-cyan-800" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path></svg><div class="pl-8 mb-2 mr-8"><p><b>Information</b></p></div><div class="pl-8 mr-8"><p>Les <code>structs</code> et les uplets pouvant encapsuler plusieurs valeurs, ce sont ce que l'on appelle des types produits, en r√©f√©rence au produit cart√©sien d'ensembles en math√©matiques. On les distingue des types dits sommes, tels que les √©num√©rations dont nous parle le chapitre 6.</p></div></div><h3 id="chapitre-6-%3A-%C3%A9num%C3%A9rations-et-match" tabindex="-1"><a class="header-anchor" href="#chapitre-6-%3A-%C3%A9num%C3%A9rations-et-match"></a> Chapitre 6 : √ânum√©rations et match</h3><p>Ce chapitre 6 nous pr√©sente les √©numerations (<code>enum</code>s), qui sont des types dont la valeur peut elle-m√™me √™tre de plusieurs types diff√©rents, mais un seul √† la fois : ce sont des types sommes, comme dit dans l'encadr√© juste au-dessus. Chacun de ces types est alors appel√© une <strong>variante</strong> de notre type √©num√©ration, ces variantes peuvent elles-m√™mes contenir des valeurs.</p><div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-cyan-500 bg-cyan-100 dark:border-cyan-800 dark:bg-cyan-950"><svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 fill-none stroke-2 stroke-cyan-500 dark:stroke-cyan-800" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path></svg><div class="pl-8 mb-2 mr-8"><p><b>Information</b></p></div><div class="pl-8 mr-8"><p>On peut alors consid√©rer chaque variante de notre √©num√©ration comme une structure, √©ventuellement unit√© si la variante ne contient aucune valeur.</p></div></div><p>Les √©num√©rations ont plusieurs utilit√©s : il se pourrait que l'on veuille, par exemple utiliser des adresses IP. Or, il existe de nos jours deux types d'adresses IP : les adresses IPv4 et les adresses IPv6. Plut√¥t que de devoir s'emb√™ter avec un type (qui serait alors une structure) pour chaque forme, on peut utiliser une √©num√©ration, et d√©finir des m√©thodes communes √† toutes les adresses IP, n'avoir qu'une seule d√©finition de fonction qui doit prendre une adresse IP en param√®tre, etc.</p><p>Cependant, cette approche demande de pouvoir distinguer les op√©rations que l'on fait selon la variante de l'√©num√©ration : c'est l√† que <code>match</code> entre en jeu. Quand on utilise <code>match</code> sur une variable dont le type est une √©num√©ration, on peut emprunter une diff√©rente branche de notre programme pour chaque variante, et, si cette variante contient elle-m√™me une valeur, on peut lier cette valeur √† une variable pour la dur√©e de la branche.</p><p>Enfin, ce chapitre nous parle des √©num√©rations <code>Result</code> et <code>Option</code>, repr√©sentant respectivement un r√©sultat, qui pourrait indiquer un √©chec ou une r√©ussite avec une valeur, et une valeur pouvant √©ventuellement valoir <code>Null</code> (qui est en quelque sorte une &quot;absence de valeur&quot;), et de certaines m√©thodes ou fonctionnalit√©s du langage que l'on peut utiliser avec ces √©num√©rations.</p><h3 id="chapitre-7-%3A-crates%2C-paquets-et-modules" tabindex="-1"><a class="header-anchor" href="#chapitre-7-%3A-crates%2C-paquets-et-modules"></a> Chapitre 7 : <em>Crates</em>, paquets et modules</h3><p>Ce chapitre 7 nous pr√©sente les <em>crates</em>, les paquets et les modules. C'est un chapitre important, relativement long et complexe, j'ai mis pr√®s d'une heure et demi √† bien l'assimiler.</p><p>En Rust, formellement, une <em><strong>crate</strong></em> est tout simplement une unit√© de code que consid√®re le compilateur. On distingue deux types de <em>crates</em> : les <em>crates</em> binaires, qui sont des programmes ex√©cutables, et les <em>crates</em> biblioth√®ques, qui contiennent des fonctionnalit√©s r√©utilisables depuis d'autres programmes. En g√©n√©ral, quand on parle de <em>crate</em>, on parle de ce second type.</p><p>Un <strong>paquet</strong> est un ensemble de une ou plusieurs <em>crates</em>, mais qui ne peut pas avoir plus d'une <em>crate</em> biblioth√®que. √Ä chacune des <em>crates</em> d'un paquet va correspondre soit le fichier <code>src/main.rs</code>, qui est la <em>crate</em> binaire principale du paquet, soit le fichier <code>src/lib.rs</code>, qui est la <em>crate</em> biblioth√®que du paquet, soit un fichier dans <code>src/bin</code>.</p><p>Enfin, tout fichier qui ne correspond √† aucun de ces chemins peut d√©finir un <strong>module</strong>, que l'on peut ensuite utiliser dans notre code avec l'instruction <code>mod &lt;nom du module&gt;</code>, o√π le nom du module est le nom du fichier sans l'extension ou le nom d'un dossier contenant un fichier <code>mod.rs</code>. Par d√©faut, tout ce que l'on d√©finit dans un module est priv√©, il faut pr√©c√©der les d√©clarations du mot-clef <code>pub</code> afin de rendre ce que l'on d√©finit accessible par le module parent et utiliser <code>pub mod</code> au lieu de <code>mod</code> pour rendre les sous-modules accessibles au module parent.</p><h3 id="chapitre-8-%3A-collections" tabindex="-1"><a class="header-anchor" href="#chapitre-8-%3A-collections"></a> Chapitre 8 : Collections</h3><p>Le chapitre 8 est consacr√© aux collections, qui sont des types contenant multiples valeurs d'un m√™me type. Ici on nous pr√©sente 3 collections : les vecteurs, les <code>String</code>s et les tables de hachage (<em>hash tables</em>). C'est √©galement notre premi√®re rencontre avec les g√©n√©riques, qui seront l√† encore vus plus en profondeur au chapitre 10.</p><p>En ce qui concerne les vecteurs, on nous pr√©sente comment cr√©er un vecteur, comment en r√©cup√©rer une valeur, ou en ajouter ou supprimer une, ainsi que comment it√©rer sur les √©l√©ments d'un vecteur. De plus, bien qu'un vecteur ne puisse contenir que des √©l√©ments d'un m√™me type, rien n'emp√™che ce type d'√™tre une √©num√©ration, donc pour cr√©er un vecteur dont les √©l√©ments peuvent avoir certains types pr√©d√©finis, il suffit d'utiliser une √©num√©ration dont les variantes peuvent contenir les types de donn√©es souhait√©es.</p><p>Ensuite, on nous pr√©sente les <code>String</code>s, qui contiennent des cha√Ænes de caract√®res Unicode encod√©s en UTF-8. En particulier, puisque ce type de donn√©es n'est &quot;que&quot; un vecteur avec quelques m√©thodes suppl√©mentaires ou l√©g√®rement modifi√©es, la majorit√© des m√©thodes disponibles pour les vecteurs sont disponibles sur les <code>String</code>s. Cependant, on ne paut pas utiliser <code>[]</code> pour r√©cup√©rer un √©l√©ment d'un <code>String</code>, puisque cela correspondrait √† r√©cup√©rer un √©l√©ment du vecteur sous-jacent, qui n'est souvent pas un caract√®re √† lui tout seul. De plus, on nous donne deux m√©thodes pour concat√©ner des <code>String</code>s, soit avec l'op√©rateur <code>+</code>, soit avec <code>format!</code>. Enfin, pour it√©rer sur un <code>String</code>, Rust nous donne deux m√©thodes : <code>chars()</code> et <code>bytes()</code>, qui permettent d'it√©rer respectivement sur les caract√®res, qui sont alors donn√©s sous forme de <code>char</code>s de Rust, et sur les octets de l'encodage UTF-8.</p><div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-cyan-500 bg-cyan-100 dark:border-cyan-800 dark:bg-cyan-950"><svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 fill-none stroke-2 stroke-cyan-500 dark:stroke-cyan-800" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path></svg><div class="pl-8 mb-2 mr-8"><p><b>Information</b></p></div><div class="pl-8 mr-8"><p>On peut r√©cup√©rer <em>une partie d'un</em> <code>String</code> en l'indi√ßant avec un <em>range</em> entre crochets, mais cela est fortement d√©conseill√© car peut causer des erreurs.</p></div></div><p>Enfin, les tables de hachage sont un type qui impl√©mente les dictionnaires : un ensemble de couples (clef, valeur) qui nous permet de r√©cup√©rer une valeur √©tant donn√©e la clef correspondante. Contrairement aux vecteurs et aux <code>String</code>s, les tables de hachage ne sont pas ordonn√©es. Enfin, l√† encore, on nous pr√©sente les m√©thodes pour ins√©rer ou enlever des √©l√©ments.</p><h3 id="chapitre-9-%3A-la-gestion-des-erreurs" tabindex="-1"><a class="header-anchor" href="#chapitre-9-%3A-la-gestion-des-erreurs"></a> Chapitre 9 : La gestion des erreurs</h3><p>Il ne me restait pas beaucoup de temps, et le chapitre 10 me semblait plus int√©ressant que le chapitre 9, donc j'ai d√©cid√© de passer le chapitre 9 pour ce MON.</p><h3 id="chapitre-10-%3A-types-g%C3%A9n%C3%A9riques%2C-traits-et-dur%C3%A9es-de-vie" tabindex="-1"><a class="header-anchor" href="#chapitre-10-%3A-types-g%C3%A9n%C3%A9riques%2C-traits-et-dur%C3%A9es-de-vie"></a> Chapitre 10 : Types g√©n√©riques, traits et dur√©es de vie</h3><p>Ce chapitre, qui est le dernier que j'ai eu le temps de lire, nous pr√©sente la programmation g√©n√©rique : ne pas se soucier des types m√™mes, mais uniquement de propri√©t√©s qu'ont les types. Par exemple, on peut d√©finir des relations d'ordres sur de nombreux types, tels que les entiers, les nombres √† virgule flottante, les cha√Ænes de caract√®res... mais dans un langage statiquement typ√© comme Rust, √† priori, il faudrait √©crire une fonction pour chacun de ces types si on souhaite par exemple trier une liste, ou en trouver le maximum. Pour rem√©dier √† cela, on va utiliser un type <strong>g√©n√©rique</strong>, et dire au compilateur que, pour que l'appel √† notre fonction soit valide, il faut que ce type supporte une relation de comparaison.</p><div class="quote relative drop-shadow py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100 dark:border-amber-800 dark:bg-amber-950"><svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 fill-none stroke-2 stroke-amber-800 dark:stroke-amber-800" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg><div class="pl-8 mb-2 mr-8"><p><b>Note</b></p></div><div class="pl-8 mr-8"><p>Il est √©galement possible d'utiliser des types g√©n√©riques dans les d√©finitions de structures ou d'√©num√©ration, de la m√™me fa√ßon que dans les fonctions.</p></div></div><p>C'est l√† qu'interviennent les <strong>traits</strong>. En Rust, un trait est un propri√©t√© qu'a un type. Par exemple, un type sur les √©l√©ments duquel est d√©finie une relation d'ordre (partielle) aura le trait <code>std::cmp::PartialOrd</code>, un type dont les √©l√©ments supportent l'addition avec <code>+</code> aura le trait <code>std::ops::Add</code>, etc. On dit alors que le type <strong>impl√©mente</strong> le trait. En g√©n√©ral, impl√©menter un trait veut dire que l'on impl√©mente les m√©thodes que doit supporter le trait. Ensuite, quand on cr√©e une fonction, un √©num√©ration, une structure... qui demande un type g√©n√©rique impl√©mentant le trait, on est garanti que l'on va pouvoir utiliser ces m√©thodes.</p><div class="quote relative drop-shadow py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100 dark:border-amber-800 dark:bg-amber-950"><svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 fill-none stroke-2 stroke-amber-800 dark:stroke-amber-800" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg><div class="pl-8 mb-2 mr-8"><p><b>Note</b></p></div><div class="pl-8 mr-8"><p>Il est √©galement possible de demander √† ce que le type g√©n√©rique impl√©mente plusieurs traits, en s√©parant les diff√©rents traits requis d'un <code>+</code>.</p></div></div><div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-cyan-500 bg-cyan-100 dark:border-cyan-800 dark:bg-cyan-950"><svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 fill-none stroke-2 stroke-cyan-500 dark:stroke-cyan-800" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path></svg><div class="pl-8 mb-2 mr-8"><p><b>Information</b></p></div><div class="pl-8 mr-8"><p>Pour les traits cit√©s ci-dessus, les m√©thodes √† impl√©menter sont en fait celles que Rust va appeler quand on utilisera les op√©rateurs <code>&lt;</code>, <code>&gt;</code> et <code>+</code>, ce qui nous permet d'utiliser directement ces op√©rateurs dans notre code.</p></div></div><div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-cyan-500 bg-cyan-100 dark:border-cyan-800 dark:bg-cyan-950"><svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 fill-none stroke-2 stroke-cyan-500 dark:stroke-cyan-800" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path></svg><div class="pl-8 mb-2 mr-8"><p><b>Information</b></p></div><div class="pl-8 mr-8"><p>Comme il est souvent chronophage d'impl√©menter toutes les m√©thodes requises pour un trait, Rust nous permet de demander au compilateur de cr√©er une impl√©mentation par d√©faut pour certains traits en utilisant la macro <code>derive</code>, mais ce n'est pas abord√© dans ce chapitre.</p></div></div><p>Enfin, ce chapitre pr√©sente les dur√©es de vie. C'est ce qui d√©termine dans quel cadre (pour combien de &quot;temps&quot;) une r√©f√©rence est valide. Cela est notamment utile quand on veut √©crire une fonction qui renvoie une r√©f√©rence ou une structure dont un des membres est une r√©f√©rence, puisqu'il faut que Rust sache quand est valide cette r√©f√©rence par rapport √† la structure ou aux arguments de la fonction. Cependant, c'est un sujet que je n'ai pas encore bien compris, et que j'esp√®re r√©ussir √† comprendre en passant √† la pratique lors du projet.</p><h2 id="conclusion" tabindex="-1"><a class="header-anchor" href="#conclusion"></a> Conclusion</h2><p>Au travers de ces 10 premiers chapitres, on a pu d√©couvrir les fonctionnalit√©s de base de Rust, comment les appr√©hender et les utiliser, et comment ces fonctionnalit√©s et son compilateur permettent de donn√©es certaines garanties de s√©curit√© et de validit√© des op√©rations qui sont effectu√©es lors la compilation, permettant d'√©viter bien des erreurs au moment d'utiliser le programme, dans un langage qui se veut pourtant relativement proche de la machine. Il reste cependant de nombreuses fonctionnalit√©s qui ne seront pr√©sent√©es que dans les chapitres suivants, donc je continuerai la lecture de mon c√¥t√©, notamment en vue du d√©veloppement sur notre projet.</p></article></main><footer class="min-h-[50px] border-t-2 mt-4 border-gray-200 dark:border-neutral-700"><div class="max-w-[1000px] mx-auto px-4"><div class="min-h-[50px] flex justify-center items-center"><p class="text-center">¬©2025 <b><span style="font-family:Consolas,sans-serif">Do-<span style="color:#4a86e8">It</span></span></b> - D√©veloppement, Management et Gestion de projets en IT</p></div></div></footer><script src="https://cdn.jsdelivr.net/npm/mathjax/es5/tex-svg-full.js" defer="">window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]]},svg:{fontCache:"global"}},document.addEventListener("DOMContentLoaded",(()=>{MathJax.typeset()}))</script><script src="https://cdn.jsdelivr.net/npm/prismjs/prism.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/toolbar/prism-toolbar.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/normalize-whitespace/prism-normalize-whitespace.min.js">Prism.plugins.NormalizeWhitespace.setDefaults({"remove-trailing":!0,"remove-indent":!0,"left-trim":!0,"right-trim":!0})</script><script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/show-language/prism-show-language.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/autoloader/prism-autoloader.min.js"></script></body></html>